{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EE4218 Lab Manuals","text":"<p>Welcome to the exciting world of embedded systems. We have prepared a series of labs for this course to give you hands-on experience in Hardware/Software Co-design. Each lab consists of two parts: 1) the first part consists of a tutorial with step-by-step guidance and 2) the second part is an assignment to allow students to use practical knowledge gained from the first part to solve a fairly simple design and implementation problem.</p>"},{"location":"#lab-info","title":"Lab Info","text":""},{"location":"#lab-venue","title":"Lab Venue","text":"<p>Lab Venue : Digital Electronics Lab (E4 level 3)  - Outreach Room</p>"},{"location":"#lab-description","title":"Lab Description","text":"Lab Description Weight Remarks 1 Introduction to Hardware Design 7% 2 Introduction to Hardware/Software Co-design 7% 3 Integrating the Co-processor 7% 4 High-Level Synthesis 7% 5 Mini Project 22% 2% for Progress Evaluation 20% for Final Demo"},{"location":"#lab-schedule","title":"Lab Schedule","text":"Week Date Activity Remarks 3 31 Jan Lab 1 Intro 4 5 Feb, 7 Feb Lab 1 Consultation, Lab 2 Intro 5 12 Feb, 14 Feb Lab 1 Demo, Lab 2 Consultation 6 19 Feb, 21 Feb Lab 2 Demo,\u00a0Lab 3 Intro Recess No session Work on Lab 3 7 5 Mar, 7 Mar Lab 3 Demo, Lab 4 Intro 8 12 Mar, 14 Mar Project Intro 9 19 Mar, 21 Mar Lab 4 Demo, Project Consultation 10 26 Mar, 28 Mar (wellness day, alternate arrangements will be done) Project Progress Evaluation and Consultation 11 2 Apr, 4 Apr Project Consultation 12 9 Apr, 11 Apr Project Demo Project Progress Evaluation and Consultation"},{"location":"#kria-board","title":"Kria Board","text":"<p>You will be provided a Kria KV260 SOM Vision Starter Kit containing a Xilinx Zynq Ultrascale+ SoC. More information about the board can be found at https://www.xilinx.com/products/som/kria/kv260-vision-starter-kit/kv260-getting-started/getting-started.html (scroll down).</p>"},{"location":"#board-handling-guidelines","title":"Board Handling Guidelines","text":"<p>Like most development boards and PCBs, your FPGA board is fragile. Treat it with care and respect, as if it were your own. It is reasonably expensive at over S$500, and not so easy to get replaced.</p> <p>Here are some tips to take good care of your board:</p> <ul> <li>Do not touch the PCB tracks, or the components on the board. Static discharge can damage or destroy electronic components, and these boards can be particularly susceptible.</li> <li>Use the nice plastic box with foam lining to transport your FPGA board. Do not use a plastic bag or other plastic container to carry your boards, and most certainly don't put it bare in your backpack/tote/briefcase/whatever you bring to class.</li> <li>When using the board, keep it on a stable, flat surface. Do NOT have it hanging off the USB cable, or hanging off the edge of a table, or on your lap, or anywhere that isn't a suitable, solid surface.</li> <li>Absolutely DO NOT DROP your board. When moving it around, hold the board by the edges and make sure the USB cable is unplugged so as to minimize strain on the port and to avoid it getting caught on something.</li> <li>Avoid plugging and unplugging the micro-USB cable more than necessary. To reset the board, you can use the power switch on the top left of the board, or unplug the USB-A connector from your computer if really necessary. Micro USB is a notoriously fragile connector, and it's best to avoid putting more strain on it than necessary. USB-A is much sturdier so that end of the cable is not as much of a concern.</li> <li>Apply common sense and standard practices for taking care of electronics: don't eat or drink near your board in case you get crumbs (or worse, a spill) on the board. Don't throw the board around. Plug and unplug accessories with care. Be gentle when using the switches and buttons.</li> </ul>"},{"location":"#policies","title":"Policies","text":""},{"location":"#late-demo-submission-policy","title":"Late demo / submission policy","text":"<p>For each assessment, you\u00a0must\u00a0demonstrate on the\u00a0stipulated date\u00a0during your\u00a0schedule time slot\u00a0as given in the assessment schedule. If you don't, you get a\u00a00 mark\u00a0for that lab!</p> <p>You are supposed to submit your codes to Canvas by the deadline for uploading - if you submit after the deadline, you will be given a 10%\u00a0discount in marks. You are expected to submit the exact same code used for evaluation - any bug fixes/improvements after the demo could you useful for future labs and project, but will not result in an increase in marks after the demo.</p> <p>A late demo is allowed (with no penalty)\u00a0only if you can produce documented evidence to justify the late demo/submission - in such a case, please let us know immediately as and when such a situation arises.</p>"},{"location":"#email-policy","title":"Email policy","text":"<p>Kindly\u00a0DO NOT send emails regarding labs wherever possible. Post see below on how to get help. Only if the matter is personal / administrative, please contact the lecturer via Canvas Inbox (not emails).</p>"},{"location":"#how-to-get-help","title":"How to get help","text":"<p>If you have any questions regarding the content of any of the labs, please follow these steps, in this order, to answer them.  </p> <ol> <li> <p>Please read the lab manual closely. We will try our best to keep the manual updated with any common errors, or issues, that you may face.</p> </li> <li> <p>If the lab manual does not answer your question, the GitHub repository has a discussions page. Please search here for your question, in case it has already been answered before. We will leave questions and answers from previous semesters on this page, so over time, more and more information should be covered between here and the manuals.</p> </li> <li> <p>If you cannot find an answer to your question in the discussions either, then please create a new discussion. Make sure your title is as succinct, but descriptive, as possible, for the benefit of others who may search the issues page later. Also, do make sure you include all relevant details in the discussion content. This webpage offers some helpful advice on how to ask good technical questions.</p> </li> <li> <p>Please DO NOT send emails to the teaching staff asking technical questions regarding the lab activities. We will ignore all such emails, with no exception. Post all technical questions to the discussions page. This benefits others, because anyone who has the issue in the future can solve it quickly with a search. It also benefits you, because you may receive an answer faster from a classmate, than from us.</p> </li> </ol> <p>On that subject, please do join in and help each other out in the discussions as far as possible.</p>"},{"location":"#plagiarism-warning","title":"Plagiarism Warning","text":"<p>It might be tempting to 'refer' to the code found in the textbook / online sources. However, please note that we take dishonesty very very seriously. If we are confident that you did plagiarize, you might not even be given a chance to explain. Consequences can range from an unpleasant surprise on the day of the release of results to having an interview with the NUS board of discipline.</p> <p>If you think renaming variables / rearranging code helps circumvent plagiarism detection, you might want to read this -\u00a0http://en.wikipedia.org/wiki/Plagiarism_detection#In_source_code.</p> <p>Discussions are encouraged, but 'we had discussed' is not a valid excuse if your codes turn out to be uncomfortably similar.</p> <p>Though there will be intra-team differentiation in marks according to the contribution levels, a team will be collectively responsible for plagiarized code. Your teammates might be better off with no contribution at all from you than to receive plagiarized code.</p>"},{"location":"#updates","title":"Updates","text":""},{"location":"#license","title":"License","text":"<p>NUS EE4218 Lab Manuals \u00a9 2024 by NUS EE4218 Team is licensed under CC BY-NC-SA 4.0 </p>"},{"location":"General/Installing_Vitis/","title":"Installing Vitis","text":""},{"location":"General/Installing_Vitis/#installing-vitis-20232","title":"Installing Vitis 2023.2","text":"<p>The complete development suite from AMD/Xilinx is also called Vitis, which includes Vivado - i.e., if you install Vitis, Vivado also gets installed. Vitis is used for the software part, Vivado is used for the hardware part.</p> <p>Installation in Linux is recommended, especially if you want to explore more. Some tools/features such as AI Engine Development Flow, Petalinux, etc are available only for Linux. The performance and stability are generally better under Linux too. The basic requirements in EE4218 can be met by a Windows installation. WSL2 seems to work too but YMMV.</p> <p>Vitis IDE is switching from being Eclipse-based to Visual Studio Code-based. However, we still recommend the Eclipse-based 'Vitis Classic' IDE as the VS based 'Vitis IDE' one does have shortcomings (e.g.: driver generation for peripherals in PL). Newer (2024.x) versions of Vitis based on Visual Studio code seems to be ok though.</p> <p>It is\u00a0not recommended\u00a0to install on MacOS through a virtual machine. If you use a Mac, install Windows and/or Linux for a dual/triple boot.</p> <p>Any version of Vivado is good enough for lab 1. For later labs, use the recommended version.</p> <p>Some features of Vitis HLS require installing a free license, which has to be generated on the Xilinx/AMD website. Instructions for that are in the last section of this page. This is not needed for the first 3 labs, so you can install the license later too.</p>"},{"location":"General/Installing_Vitis/#windows","title":"Windows","text":"<p>Below are the steps to be followed to install\u00a0Xilinx Vitis 2023.2. The instructions are for web installer, which is recommended to avoid the hassle of downloading the full installer and uncompressing it.</p> <ul> <li> <p>You need a Xilinx account. If you don't, please create one.</p> </li> <li> <p>Xilinx unified web installer is downloadable from Xilinx website (Google for it).</p> </li> <li> <p>Run the downloaded file.</p> </li> <li> <p>Click Next, and enter your Xilinx account details. In the selection below, choose 'Download and Install Now'.</p> </li> <li> <p>Agree all the license agreements on the next page.</p> </li> <li> <p>On the next page, select Vitis.</p> </li> <li> <p>On the next page, click Next.</p> </li> <li> <p>Do the selection as given in the screenshot below. Must haves are Vitis, Vivado, Vitis HLS, Install Devices for Kria SOMs and Starter Kits, Zynq UltraScale+ MPSoC, Install Cable Drivers.</p> </li> </ul> <p></p> <ul> <li> <p>Artix-7 should be selected if you plan to take CG3207/EE2026/CS2100DE in the future, else uncheck it.</p> </li> <li> <p>If you plan to try Alveo on Nimbix cloud in the future, select that too. It is unnecessary for EE4218 labs.</p> </li> <li> <p>Click Next and\u00a0Select a suitable directory, Next, and Install. If you are prompted to allow installation of some hardware, firewall warnings about opening certain ports, etc, simply click allow without changing the default options. This may also happen during the first run of certain tools after installation. Make sure you allow or you will have a tough time fixing it later.</p> </li> <li> <p>When the installation is completed, click Finish to close the wizard.</p> </li> </ul>"},{"location":"General/Installing_Vitis/#linux","title":"Linux","text":"<p>Vitis/Vivado works very well in RHEL (best-supported)/Fedora/Ubuntu. The instructions below are for Ubuntu.</p> <ul> <li> <p>You need a Xilinx account. If you don't, please create one.</p> </li> <li> <p>Xilinx unified web installer for Linux is downloadable from Xilinx website (Google for it).</p> </li> <li> <p>cd to download directory</p> </li> <li> <p>chmod +x .bin. No need sudo unless you want to install in the default /opt directory. It is fine to install under /home/, and sudo is not needed. Please make sure you install to an Ext4 directory, not NTFS.</p> </li> <li> <p>Select the options as detailed in the Windows section above and complete the installation.</p> </li> <li> <p>If the desktop icon does not work or if you are ssh-ing into a remote Linux system with x forwarding, in command line : source\u00a0//Xilinx/Vivado/2023.2/settings64.sh, followed by the command vivado.</p> </li> <li> <p>Additional libraries such as libtinfo5 may need to be installed. If starting from GUI fails, run from command line to identify the missing library and install it.</p> </li> </ul> <p>If you want to be able to access local hardware, do the following. If you are using FPGA remotely, this is not needed.</p> <ul> <li> <p>//Xilinx/Vitis/2023.2/data/xicom/cable_drivers/lin64/install_script/install_drivers</p> </li> <li> <p>Do sudo adduser $USER dialout if you want to be able to access local hardware without sudo.</p> </li> <li> <p>If you have trouble connecting to the board even after that, perhaps you should run sudo ufw allow 3121/tcp.</p> </li> </ul>"},{"location":"General/Installing_Vitis/#installing-vitis-hls-license","title":"Installing Vitis HLS License","text":"<p>Go to\u00a0https://www.xilinx.com/getlicenseLinks.\u00a0Login, fill up the license form.</p> <p>Under Certificate based license &gt; Vivado HLS License &gt; Generate Node-Locked License &gt; System Information &gt; Host ID &gt; Enter the details.</p> <p>Host ID is your PC/Laptop hostname. Select the appropriate OS. Select Host ID Type as Ethernet MAC. Put in your MAC address as the Host ID value. You can find the MAC address using the ipconfig /all command in windows (search for cmd in the start menu) and ifconfig command in Linux. Click Add and Next, Next.</p> <p>You can now download the license file . It will also be emailed to you.</p> <p>Now, in the start menu, open Xilinx Design Tools &gt; Manage Licenses 2023.2. Now Get License &gt; Load License &gt; Copy License, and navigate to and select the .lic file. Restart all Xilinx programs (Vivado/Vitis, etc). Done!</p>"},{"location":"Lab_1/1_Intro/","title":"Introduction to Hardware Design","text":""},{"location":"Lab_1/1_Intro/#introduction","title":"Introduction","text":"<p>The purpose of Lab 1 is to introduce you to systematic hardware design. The lab has a refresher of the hardware design flow from EE2026. Lab 1 can be done on any version of Vivado/Vitis without issues. Lab 1 does not require the FGPA board - it is pure simulation.</p> <p>To learn further, you will be doing an assignment that involves creating a coprocessor for matrix multiplication.\u00a0Testing on real hardware will require a complete computer system (hardware-software co-design framework), which\u00a0will be introduced in Lab 2. The actual integration will be\u00a0done in Lab 3. When integrated into the system, the main processor can just stream the data to be processed to the coprocessor, which will do the computations and stream the results back to the main processor.</p>"},{"location":"Lab_1/1_Intro/#creating-and-simulating-hdl-sources-and-programming-fpga","title":"Creating and Simulating HDL Sources and Programming FPGA","text":"<p>Those who are already familiar with Vivado and FPGA implementation can skip this step and go straight to the assignment problem. Others can refer to the CS2100DE Lab 1 manual, which contains step-by-step instructions for the creation of HDL files, simulation, and FPGA implementation. The FPGA used in this course is different from that used in CS2100DE, so the input/output pin numbers to be used in the .xdc file are different.</p>"},{"location":"Lab_1/1_Intro/#assignment-1","title":"Assignment 1","text":"<p>Assignment #1 is a homework exercise and carries 7 marks. It involves the creation of an accelerator IP for matrix multiplication.</p> <p>The accelerator IP that we create needs to be interfaced with the rest of the system for the processor to make it act as a coprocessor. The interface of an accelerator can be</p> <ul> <li>Register-based: The processor can read and write the registers within the coprocessor to write inputs/read outputs - each register has an address within the address space of the processor. The parameters and return values are mapped to these registers/addresses. For example, A is in the offset range 0xx to 0xyy - the actual address range is the base address of the coprocessor peripheral (assigned in Vivado under the address tab) + the offset. The coprocessor in this case has an AXI or AXI Lite interface which can be connected to the AXI bus of the system as a slave.</li> <li>Stream-based: There are separate input and output streams through which the data is streamed in/out. There is no concept of addresses, and the meaning of the data is derived from the order of the data (and possibly some 'tags'). For example, the first 512 words correspond to A, the next 64 correspond to B, and so on. Please read the Introduction to AXI Stream below.</li> <li>Memory-based: The co-processor reads inputs from / writes output to memory directly.</li> </ul> <p>For now, we will start with Stream-based which is perhaps the easiest to get started.</p>"},{"location":"Lab_1/1_Intro/#introduction-to-axi-stream","title":"Introduction to AXI Stream","text":"<p>The hardware we are going to develop makes use of the\u00a0Advanced eXtensible Interface (AXI) Stream interface to simplify the data receiving and sending processes. The AXI-Stream (AXIS) channels are 32-bit synchronous, master-slave, simplex (uni-directional flow of data per channel), point-to-point (only 2 devices are involved - no addressing needed) communication interfaces. A typical coprocessor needs one AXIS channel for inputs (AXIS Slave) and one AXIS channel for outputs (AXIS Master).</p> <p>To see more on AXIS:\u00a0http://www.xilinx.com/support/documentation/ip_documentation/ug761_axi_reference_guide.pdf</p> <p></p> <p>The AXIS bus protocol is illustrated below (taken from the document in the link above).</p> <p>Data transfer is always from a Master interface to a Slave interface. This means a hardware block will receive data (input) through its slave interface (let's call it S_AXIS), and send data (output) through its master interface (let's call it M_AXIS).</p> <p>TVALID is an indication from the master to the slave that the data placed by the master on TDATA is valid.</p> <p>TREADY is an indication from slave to master that the slave is willing to accept data. The slave should capture the data at the very next active clock edge if TVALID and TREADY are both true. However, the master is not obliged to send any data simply because TREADY is asserted by the slave.</p> <p>TLAST is an indication from the master to slave that the current data word is the last. TLAST is considered a sideband signal and is optional for AXIS. All the other signals mentioned above are essential signals for AXIS.\u00a0It is useful in scenarios where the slave doesn't know exactly how many data words are sent by the master and is required if the slave is AXI Stream FIFO or AXI DMA, as these IPs (we will see in Lab 3) expect it.</p>"},{"location":"Lab_1/1_Intro/#axis-matrix-multiplication-coprocessor","title":"AXIS Matrix Multiplication Coprocessor","text":"<p>Let\u00a0A\u00a0be an m\u00a0\u00d7 n matrix of your choice, containing elements between 0 and 127, each value represented as an 8-bit unsigned number. The coprocessor receives the elements of A\u00a0as 32-bit numbers, of which the most significant 24-bits are 0s\u1dbf, one element per clock cycle through S_AXIS_DATA following the AXIS\u00a0 bus protocol. You can assume a row-major order, i.e., the first n values received are elements of the first row, the next n values elements of the second row, and so on. For now, let us assume that m = 2 and n = 4.</p> <p>Let B\u00a0be an n\u00a0\u00d7 1 matrix of your choice, received through\u00a0S_AXIS_DATA in a similar manner as A, after all the elements of A have been received. In other words, the first m*n elements belong to matrix A, and the next n elements belong to matrix B.</p> <p>The coprocessor needs to find the product of\u00a0A\u00a0and B and divide it by 256. i.e RES =(A\u00a0* B) / 256. Naturally,\u00a0RES has to be an m \u00d7 1 matrix.</p> <p>The elements of RES should be sent out of the coprocessor through M_AXIS_DATA following the AXIS\u00a0 bus protocol, one element per clock.</p> <p>The system should be able to operate continuously. Soon after (doesn't necessarily mean the very next clock cycle; within 2-4 clock cycles is ok), the coprocessor should be able to receive the next set of inputs, i.e., the next A and B\u00a0without the need to assert an external reset.</p> <p>\u1dbfIn fact, the most significant 25 bits are 0s since the number is between 0 and 127. However, let us just stick to the principle that we are dealing with an 8-bit unsigned number. Think of the values you send as representing the fractional part alone in unsigned fixed-point notation (0.8 - 0 bits for the integer part and 8 bits for the fractional part), i.e., using an implicit scale factor of 256. This requires us to adjust the position of the point by dividing by the scale factor after multiplication. This adjustment is unnecessary for addition and subtraction. Does this ring a bell? In EE/CG2028 Assignment #1, you used a scale factor to avoid dealing with fractions. Same story here; the scale factor is 256 instead of a power of 10.</p>"},{"location":"Lab_1/1_Intro/#coprocessor-logic","title":"Coprocessor Logic","text":"<ul> <li>You need to have two RAMs - one each for\u00a0A and B, and one element of either A or B can be populated with the incoming element through S_AXIS_TDATA in the 'Read_Inputs' state. You can also split the\u00a0'Read_Inputs' state into two separate states for storing A and B.</li> <li>Once all the values have been stored into A and B RAM(s), you will need to assert the 'Start' signal to the Matrix_Multiply unit.</li> <li>The\u00a0Matrix_Multiply unit reads\u00a0A and B RAMs and computes the product/256, element by element. Each element of the result is written into the appropriate location in the RES RAM.\u00a0Matrix_Multiply will assert a 'Done' signal when the computation has finished.</li> <li>You will need to populate the 'Compute' state during which your coprocessor waits for the 'Done' signal from the\u00a0Matrix_Multiply unit.</li> <li>Once the 'Done' is received from\u00a0Matrix_Multiply unit, the contents of RES RAM should be sent out through M_AXIS_TDATA in 'Write_Outputs' state.</li> <li>After this, the system goes back to 'Idle' state. Note that you do not have to reset the RAM contents. However, other counters, etc might need to be reset.</li> <li>'Start' and 'Done' can be implemented /assumed to last for exactly one cycle.</li> </ul>"},{"location":"Lab_1/1_Intro/#design-considerations","title":"Design Considerations","text":"<ul> <li>There is no need to implement your own multiplier, you can use the * operator.</li> <li>Division by 256 is easy and does not require a division operation. Say you want to divide a 16-bit number P by 256 to get an 8-bit result Q. It is as simple as Q = P[15:8]. This wouldn't have been possible if the scale factor was a power of 10 - humans like decimal number system as we have 10 fingers and it is easier for us to do math modulo 10, computers don't.</li> <li>There could be potential advantages in using matrix dimensions\u00a0which are powers of two. Using powers of two makes certain indexing-related multiplications (and divisions, as noted in the point above) easier - it can be done using shifts. Multiplication by 2^k^ is shifting left by k positions. Shifting by a constant amount (i.e., when k is a constant) does not require any hardware - it is just a matter of wiring / connecting appropriately (hint: the idea is similar to how it was done for division by the 256 above). Shifting by a variable amount (i.e., when k is a variable) will require hardware shifters - shifters are still much faster and take less hardware than multiplication/division.</li> <li>You are allowed to make reasonable changes to the RAM, but the RAM reading should not be made asynchronous.</li> <li>You can choose to have a single RAM to store both A and B, read the appropriate elements later, one at a time, and then operate on them. This will be slower (our current implementation of the RAM allows reading of only one value at a time). However, it is possible to change the RAM design by giving it the ability to read two values simultaneously (dual port).</li> <li>You can also Google Block RAMs (also called Dedicated RAMs), Distributed RAMs, and Registers in Xilinx/AMD FPGAs (it is also explained in the synthesis manual), and how they can be used in your design. It is recommended to use synchronous read for most applications, as it gives you good timing performance.</li> <li>Registers - Can read multiple values asynchronously, that is, we get the data in the specified address location without waiting for a clock edge. High synthesis time, poor timing performance (adds significantly to the critical path), and overall hardware utilization. A number of CLBs are required even for relatively small registers.</li> <li>Block RAM - Can be read only synchronously, that is, we need to give address, and wait for a clock edge before we can read data. Very good timing performance and does not use up CLBs. Up to 2 values can be read in a cycle. Ultra RAM is quite similar in functionality to Block RAMs</li> <li>Distributed RAM - A Xilinx special way of implementing RAM using LUTs. Can be read asynchronously, up to 2 values. Uses up LUTs and timing performance is average. Small synchronous-read memories also may infer BRAMs, with registered outputs. </li> <li>Writes are always synchronous, irrespective of the type of storage used.</li> <li>Read up about instantiation vs inference!</li> <li>Think about the implications of having a single\u00a0Read_Inputs state vs splitting it into two states (hint: as is with many things in hardware, it is not easy to tell, but the implications are likely not very big)!</li> <li>Implement your system in a modular, systematic manner. Do not write a C-like code. You should be able to justify all your design choices.</li> <li>How many cycles does it take for your hardware to complete the operation? Note: You should be able to calculate this based on your design (since you know the exact sequence of operations, i.e., what happens in each cycle), without having to look at your simulation result (you look at the simulation results to verify it).</li> <li>A well-designed testbench is expected (not only for this lab but for all hardware parts you implement for EE4218). For the most part, slight modifications to the provided testbench should do.</li> <li>Your design should be able to synthesize without any unavoidable warnings.\u00a0You will need to inspect the\u00a0resource usage details such as the number of slices/LUTs etc. Note that the estimates we get post-synthesis are preliminary estimates, the ones we get post-implementation are accurate figures. We need to do only synthesis for now.</li> <li>You should do both behavioral simulation as well as post-synthesis functional simulation. The former runs faster and aids you in debugging functional aspects. The latter simulates the synthesized design, which is slower and harder to debug but is a good indication of whether your design will work on actual hardware. The good news is that post-synthesis functional simulation can be done with no extra effort - the testbench used is the same.</li> <li>Your design should be such that it is easy to change matrix dimensions (m and n) with minimal effort. Ideally, it should be parameterized, but at the least should be designed in a flexible enough manner. The second dimension for B can be fixed to 1 for simplicity.</li> <li>Having a separate Matrix_Multiply unit is inefficient with respect to performance as well as hardware usage, in comparison with doing everything in the top-level module. That would have allowed you to start computations earlier, and send out the elements of RES as soon as they were computed. However, in practical designs, such inefficiencies are generally tolerated in favor of modularity. Modularity allows for different parts of the hardware to be independently designed, debugged,\u00a0tested, and improved, possibly by different people or teams. It also allows for modules to be reused across designs, allowing for faster time to market.</li> <li>For a coprocessor to be useful in practice, the overhead associated with sending the data from the main memory (system DDR RAM)\u00a0to the coprocessor local RAM and receiving the results back should be more than compensated by the acceleration provided by the coprocessor. We will do a comparison when we do the project.</li> <li>Elements of the input matrices being between 0 and 127 will guarantee that the result will not exceed the representation range possible with 8-bits. n*127*127/256, where n = 4\u00a0is less than 255. In terms of decimal numbers, each number is less than 1/2, so each element of the result will be less than 1. An element being 1 or more will be troublesome, as we have 0 bits to represent the integer part.</li> <li>An 8-bit (or any #bit) binary pattern can be used to represent a lot of things, not just integers. For example, it could be an integer between -128 to 127 (signed 8-bit integer), 0 to 255 (unsigned 8-bit integer), 0 to 255/256 (unsigned 0.8 fixed-point format), 0 to 1+127/128 (unsigned 1.7 fixed-point format), -1 to 127/128 (signed 0.7 fixed-point format), a mini floating-point number (in floating-point representation, the position of the point is explicitly encoded as an 'exponent', unlike fixed point where the position of the point is fixed/implicit), a character (ASCII or UTF-8), 2 digits to be displayed on 7-segment LEDs (BCD format), or even the on/off status of 8 lights in a room. As a designer (hardware and/or software), we have to make sure that the operations we perform, the adjustments we make, and the interpretation of results should all be consistent with the representation system we use.</li> </ul>"},{"location":"Lab_1/1_Intro/#files-templates","title":"Files / Templates","text":"<p>You can find all lab 1 files here</p> <ul> <li> <p>myip_v1_0.v\u00a0/ myip_v1_0.vhd - top-level module implementing the AXIS coprocessor. Currently, it simply takes in 4 words over 4 cycles and returns their sum, sum+1, sum+2, and sum+3 over 4 cycles. You need to modify this appropriately to interact with RAMs and Matrix_Multiply unit. You should not modify the inputs/outputs of myip_v1_0.v / myip_v1_0.vhd, as they should follow the AXIS standard. Synthesizing this will yield 56 warnings (could change slightly depending on the version of the tool) which are expected since memory and matrix multiply units are not used in the template code.</p> </li> <li> <p>memory_RAM.v\u00a0/ memory_RAM.vhd\u00a0- memory to implement A, B, and RES. There is no need to modify this. It should be used as a component (you will need one instance for each RAM, with appropriate parameters used for width and depth) in\u00a0myip_v1_0.v. It is fine to modify it if you really want to, as long as the read is synchronous.</p> </li> <li> <p>matrix_multiply.v\u00a0/\u00a0\u00a0matrix_multiply.vhd\u00a0- a skeleton template for the actual matrix multiplication. Upon receiving the 'Start' signal, it reads from\u00a0A and B RAMs, performs the fixed point multiplication, writes the result to RES RAM, and then asserts the 'Done' signal. This needs to be implemented properly and should be used as a component in myip_v1_0.v.</p> </li> <li> <p>test_input.mem\u00a0- test vector input to the coprocessor; used by the testbench (tb_myip_v1_0.v). The numbers in the file should be in hex (2 hex digits = 8 bits).</p> </li> <li> <p>test_result_expected.mem\u00a0- expected output to validate the output given by the coprocessor; used by the testbench (tb_myip_v1_0.v/vhd).\u00a0The numbers in the file should be in hex (2 hex digits = 8 bits).</p> </li> <li> <p>tb_myip_v1_0.v\u00a0/\u00a0tb_myip_v1_0.vhd\u00a0- a self-checking testbench for the coprocessor (myip_v1_0). It tests the addition functionality as mentioned in the description for the original myip_v1_0.v/vhd above.</p> </li> </ul> <p>It reads in an input vector from test_input.mem and passes it to the coprocessor, gets the result vector from the coprocessor, and compares it with the expected result vector in the file test_result_expected.mem. The testbench does this for two different test vectors (cases). If the actual result vector tallies with the expected result vector for both the test vectors (cases), it will print a message 'Test Passed', else, it prints 'Test Failed'. Note that in this example, the input vector, result vector, and expected result vector are all having 4 elements per test case.</p> <p>You can add the .mem files to the project and Vivado will automatically recognize it as a memory file and will add it under Simulation Sources &gt; Memory File. Alternatively (i.e., instead of adding it to the project), you can specify the full path to the files in the testbench - use forward slashes for the path to the test files, even on Windows, kind of like URLs.\u200b</p> <p>The testbench can be modified very easily to test the matrix multiplication coprocessor. You will also need to change the input and output .mem files appropriately. For each test case, you need to have a vector of 12 elements (8 for A and 4 for B) for input, and the expected result vector will have 2 elements (RES).</p> <p>Verilog and VHDL files can be freely mixed. For example, you can use\u00a0memory_RAM.v instead of memory_RAM.vhd as a component of myip_v1_0.vhd.</p>"},{"location":"Lab_1/1_Intro/#general-tips","title":"General Tips","text":"<ul> <li>As a general rule, DO NOT use spaces in the paths for any of your projects / workspaces. This is a good practice not only for Vitis/Vivado, but for a number of hardware and software development tools.</li> <li>Understand the given templates and testbenches very well. Run the testbench and see the example (addition) functionality. If you don't understand it and if you are trying to modify it, you are flying blind.</li> <li>Go to Tools &gt; Settings &gt; Tool Settings &gt; Text Editor &gt; Tabs and check .use tab character'. This will help keep your code properly indented. There are only two types of people in this world - those who indent their code with tabs, and those who do not know how to indent.</li> <li>Read Lecture notes thoroughly and make sure your code is synthesizable. Your design is ideally an interconnection of templates for the various digital building blocks, rather than a direct expression of your logic. https://www.xilinx.com/support/documentation/sw_manuals/xilinx2019_2/ug901-vivado-synthesis.pdf\u00a0provides a number of templates. In Vivado, Help&gt;Design Hubs&gt;Synthesis, as well as Tools&gt;Language Templates&gt;Verilog/VHDL&gt;Synthesis Constructs could be useful too.</li> <li>See the elaborated design (under RTL Analysis) to see if the schematic matches your intended design. Look into the components inferred, inputs and outputs of each block, bit widths, etc.</li> <li>Inspect the synthesis report to see if the 'Detailed RTL Component Info' (basic digital building blocks inferred) makes sense.</li> <li>Explore other reports too (such as utilization - number of LUTs used etc, timing).</li> <li>Synthesize submodules separately to see if they are ok. The synthesis tool is more intelligent than the simulation tool, and the synthesis warnings usually give you very good clues regarding potential issues with your design such as possible wrong connections\u00a0 (I generally look for synthesis warnings even before I simulate). You should also test the relevant submodules using testbenches if need be (though unnecessary in this particular case unless you modularize further).</li> <li>Being familiar with debugging properly, such as running until a breakpoint, running for a specified time, stepping 1 clock at a time (running in 100 ns increments), inspecting the results as well as internal variable values at each instant (using 'Scope' and 'Objects' tabs), etc can save you A LOT of time. Don't try changing one or two lines here and there and try running over and over.</li> <li>You might want to change the radix to hexadecimal or decimal as appropriate in the waveform window. You can save the .wcfg file by pressing Ctrl+S when the waveform window is highlighted. Add it to the project when it prompts you. This will allow the radix changes etc to be saved. You can also drag specific objects (variable values, from Scope &gt; Objects, even for internal modules) to the waveform window to inspect them. You will have to press the Restart button (Ctrl+Shift+F5), and then Run for a specified time (Shift+F2) to see the waveform of the newly added object. There is no need to Relaunch simulation.</li> <li>It might take a bit of time, effort, and frustration before you can write good synthesizable code. Sometimes, you can't get a better teacher than experience, especially so when it comes to writing good HDL code. Just hang in there and you will be ok soon. The best bet is to go through the notes and have the hardware in mind while writing the code.</li> <li>When simulating a system with a clock divider / enable, either bypass the clock divider or set the modulus (number of bits for the counter) to a very small value. Otherwise, you might have to wait for 2^26 cycles (for a 1Hz clock) before you can see the effect of 1 clock edge! This is not applicable to this lab, as you don't have any reason to have a clock divider / enable.</li> <li>Vivado (and most EDA tools) allow scripting and automation using Tcl. You can save the various commands from the Tcl Console as a .tcl file and run it! This may be useful for later labs.</li> <li>Antivirus programs can mess with simulation as the simulation creates .exe files that Antivurs might view as suspicious.</li> <li>Sometimes, the executables run during simulation might not quit cleanly, creating issues with simulation. Closing Vivado and killing all related processes from the Task Manager (Ctrl+Shift+Esc) can help. Worst case, try rebooting your system.</li> <li>If it still doesn't work, delete all the files/folders in the project folder except .xpr, .wcfg , .srcs (assuming that is where your design/simulation sources are, which is the case if you had checked the option 'copy to the project folder' when you added the file)."},{"location":"Lab_1/1_Intro/#submission-info","title":"Submission Info","text":"<p>Demonstrate during your designated slot in Week 5. Upload a very short (&lt;=2 pages) report explaining your system architecture, FSM, resource usage details such as the number of slices/LUTs, etc., as well as the relevant .v/.vhd (RTL and testbenches) and .txt/.mem files (i.e., only those files you have created/modified, not the entire project folder) used for the demo (not modified to fix issues that became apparent during the demo) to Canvas within 1 hour of your demo. It should be as a .zip archive, with the filename Wed/Fri_GroupNum_Lab1.zip.</p>"},{"location":"Lab_2/1_Intro/","title":"Introduction to Hardware/Software Co-Design","text":""},{"location":"Lab_2/1_Intro/#introduction","title":"Introduction","text":"<p>This manual contains step-by-step instructions on how to create a hardware platform that utilizes the ARM Cortex A53 processor in the Kria board (there are two of them; we will be using only one through) and to execute simple C programs on it. The following 3 pages have the details you will need in the process.</p> <p>Creating the hardware platform - This page describes how to use Vivado to create a hardware platform using IP Integrator, and to synthesize the hardware into a bitstream. The bitstream is used to configure the FPGA to become the hardware platform that we have created. The bitstream and other hardware info are exported as a .xsa file.</p> <p>Software development using Vitis Classic - This page describes how to use VItis - Eclipse-based IDEs to create a C program to run on the Cortex A53 processor and interacting with the peripherals we have integrated in the step above.</p> <p>Serial Console - RealTerm - This page describes how to use RealTerm, the recommended console program (you are free to use other serial terminal programs or even have your own program for the purpose, e.g., a custom Python code using PySerial library) to send and receive information to the program running on the Cortex A53 processor through UART.</p>"},{"location":"Lab_2/1_Intro/#assignment-2","title":"Assignment 2","text":"<p>Assignment #2 is a homework exercise and carries\u00a07\u00a0marks.</p> <p>All the required files are here</p> <p>The matrix A is a 64 x 8 matrix given in A.csv (CSV = comma-separated values). The elements of A are in the corresponding ASCII form in A.csv - this is essentially a text file and can be opened using a text editor*. You can also open it with Excel, which will show it as a table. The matrix B is an 8 x 1 matrix given in B.csv, encoded in a similar manner as A.csv. These two files should be sent from RealTerm to your C program running on board. Your C program should receive it and compute the result matrix, RES \\=\u00a0A*B/256.\u00a0This should be sent back from the board to the PC (RealTerm), where it should be captured into a file. The name of the file has to be \u201cRES.csv\u201d.\u00a0 You can compare the RES.csv with Labels.csv on your PC using an Excel-like program (i.e., Labels.csv should not be sent to the board). Do you observe any pattern?</p> <p>You should do all computations in C on the board using integers. Do not use floating-point (i.e., variables should not be declared as float).\u00a0</p> <p>Note that the program you wrote runs on the board, and it cannot access files on your computer and the typical C file operations would not work - those work only if the file is on the same computer running the program. So the data has to be sent / received through console (RealTerm), eventually received / sent by the C\u00a0program through UART (forwarded through a TCP/IP socket).\u00a0What your C program sends / receives is a stream of ASCII characters. This has to be parsed and converted to integers.\u00a0Functions such as scanf() can do this for you.</p> <p>If your program is inhibiting unpredictable behavior when dealing with large data, it could be due to stack or heap size limitations. You can increase the heap or stack size by editing the linker script (.ld file) which you can find in the project sources.</p> <p>You can do most of the testing of your C program logic without accessing the FPGA board. You can run it locally using a C/C++ IDE of your choice (such as\u00a0 Visual Studio Code) or using an online compiler like\u00a0https://www.onlinegdb.com/online_c_compiler. Since the typical console (interface) you get cannot send files (such as A.csv and B.csv), you can copy-paste the file contents on the console, line by line, with the enter key pressed at the end of each line. If the console of the IDE you are using does not support copy-pasting, you will have to type it out. You can experiment with smaller matrices first to avoid wasting time doing too many copy-pastes.</p> <p>*An editor such as Notepad++ can show you all characters, including non-printable characters such as \\r (CR-carriage return) and \\n (LF-linefeed). You can view it by going to View&gt;Show Symbol&gt;Show All Characters. When sending using the 'Send ASCII' option in RealTerm, make sure you append \\r or \\n.</p>"},{"location":"Lab_2/1_Intro/#submission-info","title":"Submission Info","text":"<p>Assignment 2 (7 marks)</p> <p>Demonstrate during Week 6 lab session.</p> <p>Upload</p> <p>Upload the .xsa file, C/H, and input/output test files (i.e., only those files you have created/modified, not the entire project folder) used for the demo (not modified to fix issues that became apparent during the demo) to Canvas within 1 hour of your demo. It should be as a .zip archive, with the filename Wed/Fri_GroupNum_Lab2.zip.</p> <p>Please DO NOT upload the whole project!</p>"},{"location":"Lab_2/1_Intro/#dataset-description-optional-read","title":"Dataset Description (Optional Read)","text":"<p>Here, we use a modified version of the Wine dataset from\u00a0https://archive.ics.uci.edu/ml/datasets/wine. You can read up the description and more if you are interested.</p> <ul> <li>The original 3-class problem is reduced to a 2-class problem by removing the cases with label 3.</li> <li>Some features are also removed, to reduce the feature dimensionality from 13 to 8.</li> <li>The original features are normalized to be between\u00a0[0, 1), represented using the 0.8-bit fixed point representation we had used in Lab 1.</li> <li>You can visualize the data using some easy-to-use programming language such as Python or Matlab (https://octave-online.net/ is pretty cool), or even Excel.</li> <li>What we do in this lab is essentially the prediction / inference step in machine learning / classification. The classifier is trained using Fisher's linear discriminant\u00a0method (matrix B\u00a0in the description above is the weight vector), with some modifications to accommodate the 8-bit format.</li> </ul>"},{"location":"Lab_2/1_Intro/#tips-and-suggestions","title":"Tips and Suggestions","text":"<p>Embedded system tools and boards have a relatively short lifespan - so you need to be able to pick up things on your own as and when required, often based on partial documentation and self-exploration. Lab 2 manuals have purposely left out detailed step by step instructions (esp. on the software part) - to let you explore the various options, think, search and find out things on your own. If you know precisely how to do it (that is, if we give you detailed steps), doing it shouldn\u2019t take you much time and is not worth 7% of you grades :D. Some tips are given below.</p> <ul> <li>There are 2 programs with interact with each other \u2013 the RealTerm program which runs on the PC, and your C program running on the board.</li> <li>RealTerm is a serial terminal / console program* running on PC. It can send and receive characters, send and receive text files (text files are nothing but long strings) through the serial port (COM/tty) as well as network interfaces (TCP/IP sockets).</li> <li>The program running on the board (Cortex A53) receives the sequence of characters sent from the PC (you can use the send file option in RealTerm), does some computations, and sends it back to the PC (you can capture it into a file). Since this is running on the board which does not have direct access to the files on the PC, usual file related functions such as fopen() and fprintf() will not work!. You can only capture the stream of characters sent by the RealTerm, process it, and send back.</li> <li>Now the question on how to receive data sent from RealTerm in your C program - there are 2 approaches :<ul> <li>The high-level way using stdin / stdout.\u00a0<ul> <li>stdin and stdout are interfaces through which console-oriented functions such as\u00a0printf(), scanf(), getchar(), gets(), putchar(), puts() send data to be displayed on\u00a0the console and receive data from the console</li> <li>Since we have directed stdin and stdout to the console (where did we do that? - I leave it as an exercise for you to find out), you can use these functions to send and receive data from the PC/RealTerm.\u00a0</li> <li>One catch-all the functions block until a\u00a0LF (linefeed - \\n) or CR(carriage return - \\r) is received. So you can't receive anything which is not properly terminated. When you send a file, make sure that it has a \\r or \\n character at the end of it. This is automatically inserted when you press 'enter' in a text file or console (Most windows programs treat the press of 'enter' as \\r\\n, whereas in Linux, it is usually just \\n. For most console programs, it is '\\r' by default. These characters come from the typewriter era and mostly serve the same purpose on a computer).\u00a0</li> </ul> </li> <li>The low-level way using UART driver functions<ul> <li>Gives you full control over what is sent and what is received to/from the console.</li> <li>You need to initialize the UART driver before you can use functions such as\u00a0XUartPs_Send() and\u00a0XUartPs_Recv() or the lower level XUartPs_SendByte() and\u00a0XUartPs_RecvByte().\u00a0</li> <li>These are non-blocking functions (so you need to check the return value to see how many characters you have received) which give\u00a0you full control (no need for \\r or \\n).\u00a0</li> <li>The basic procedure to deal with all hardware in the Xilinx toolchain is the same, as exemplified below through\u00a0XUartPs. You can go to $your_Bsp$&gt;system.mss and see the driver documentation and examples.<ul> <li>XUartPs Uart_Ps\u00a0//Declare a driver instance (not a pointer to this instance) as a global variable. All UART related functions use a pointer to this instance.\u00a0</li> <li>XUartPs_LookupConfig(DeviceId); // Looks up hardware instance info such as base address etc.\u00a0DeviceId is usually\u00a0XPAR_XUARTPS_0_DEVICE_ID, defined in xparameters.h.\u00a0</li> <li>XUartPs_CfgInitialize(&amp;Uart_Ps,...)\u00a0// Initializes the hardware and driver instance</li> <li>XUartPs_SetBaudRate(&amp;Uart_Ps,...)\u00a0// Additional hardware specific settings/initializations. Following this, you can use the Send and Recv functions.</li> </ul> </li> <li>Instead of starting from scratch, start with the examples from system.mss entry for the hardware your are looking at. For UART, you can probably start with\u00a0xuartps_hello_world_example and modify it to suit your needs.</li> </ul> </li> </ul> </li> <li>Instead of just clicking 'Run' in the Vitis, you can click 'Debug' and do debugging just like how you do on any IDE. To change your perspective back to normal (after debugging), click Window&gt;Debug Perspective in Vitis. This will allow you to inspect what is happening in each line, send something from RealTerm and see what is received etc.</li> <li>*RealTerm is a very feature-rich terminal / console program. Don't be afraid to try out the various options in the tabs 'Display', 'Capture', Send'. Most importantly, the settings on Port has to be correct for things to work. Generally, I uncheck 'Direct Capture' and check 'Half Duplex' and 'newLine mode' so that I can see everything that is sent and received on the console.</li> <li>If you see strange-looking characters on your console, your baud rate setting in RealTerm is likely wrong.</li> <li>As a general rule, DO NOT use spaces in the paths for any of your projects / workspaces. This is a good practice not only for Vitis/Vivado, but for a number of hardware and software development tools.</li> <li>Sending data from RealTerm/Serial console everytime can be time-consuming during the debug process. It is a good idea to have the required data (CSV file contents) hard-coded as an array in your C program, and use it during debugging. You could make use of #ifdef to conditionally use the hardcoded value or the live data streamed in from the serial console so that you can switch between them easily.</li> </ul>"},{"location":"Lab_2/2_HW_Platform/","title":"Creating the Hardware Platform","text":"<p>This page describes how to use Vivado to create a hardware platform using IP Integrator, and to synthesize the hardware into a bitstream. The bitstream is used to configure the FPGA to become the hardware platform that we have created. The bitstream and other hardware info are exported as a .xsa file.</p> <p>Open Vivado.</p> <p>File&gt;Project&gt;New</p> <p>Next&gt; Specify a project name and location&gt;Next&gt;Next&gt;Next&gt;Next&gt; Select the board - go to the boards tab and select\u00a0Kria KV260 Vision AI Starter Kit SOM &gt;Next&gt;Finish.</p> <p></p> <p>Vivado Project manager will now open up.</p> <p>Under IP Integrator, click Create Block Design.</p> <p></p> <p>Accept the default name and options, and click OK.</p> <p>In the IP Integrator canvas that opens up, click the Add IP button .</p> <p>Search for and add Zynq UltraScale+ MPSoC</p> <p></p> <p>Click on Run Block Automation. This will apply some preset settings for the chip/board. We will be changing this substantially later though.</p> <p></p> <p>Accept the defaults and press ok.</p> <p>Now double-click on the Zynq Ultrascale+ block. You can now see the ultrascale+ block diagram. Have a good look.</p> <p>No, under I/O configuration, enable UART and you can safely disable everything else. Here, we are configuring the multiplexed IOs, and\u00a0MIO pins 36 is TX, 37 is RX. We need only those for now.</p> <p></p> <p>In the Clock configuration, you can uncheck PL1. PS generates clock(s) for PL. We can have multiple clocks with the same or different frequencies. We need only one 100 MHz clock for PL, at least for now.</p> <p></p> <p>In the PS-PL configuration, we can choose AXI HPM0 FPD and uncheck AXI HPM1 FPD. Using AXI HPM0 LPD is also ok (FPD = full power domain. LPD = low power domain). This is the master AXI interface, to which the slaves created in PL will be connected. Select the data width as 32.</p> <p></p> <p>You should now see the block below. Click and drag from pl_clk0 to make a connection to maxihpm0_fpg_aclk.</p> <p></p> <p></p> <p>At any point, if you want to beautify the layout, you can click </p> <p>The validate your design, i.e., to check if there are incompatible connections / essential connections that are not made, click . If no error or critical warning, we have completed the basic block design.</p> <p>While this is good enough to do the basic requirements for this lab, let us push ourselves a bit more and get readier for future labs.</p> <p>Click the + button on the IP Integrator canvas to add an IP. Select AXI-Stream FIFO.  . This IP acts as a bridge between AXI (the bus-based, addressable bus system) to AXI-Stream (point-to-point, non-addressable link). This will be used to integrate our coprocessor into the rest of the system in future labs so that the main processor can send/receive data via AXI.\u00a0</p> <p>While the IP Integrator shows the option for running connection automation, do not do this as yet. Instead, double-click on the AXI Stream FIFO that we added to customize it.</p> <p>Change the settings as follows, and click OK. Choosing AXI (full AXI) instead of AXI Lite (default) allows the data transfer to be potentially faster, as full AXI can do burst transfers (slave auto-increments addresses so that multiple data can be transferred with a single address). We can disable 'Enable Transmit Control' as we will be doing all the data transfer continuously. Make sure that the Data Width is 32. Increase the Transmit FIFO depth to 1024, as we will be sending more than 512 words later.</p> <p></p> <p>Now, click on </p> <p>Select both the automations and click OK.\u00a0</p> <p></p> <p>It will add two blocks - Processor System Reset (to reset peripherals as appropriate - more useful in designs using Microblaze, a soft processor), and an AXI Interconnect (since AXI Stream FIFO has 2 slave interfaces, both of which need to be connected to the same master interface of PS.</p> <p>Finally, make a loopback connection - connect the AXI_STR_TXD to AXI_STR_RXD. Since we do not have a co-processor yet, this connection will have the effect of a coprocessor that simply echos (sends back) the data it receives.</p> <p></p> <p>You can now optionally click on Regenerate Layout button (the clock-wise symbol) to tidy up the diagram. It should look like below.</p> <p></p> <p>It is also a good time to inspect (no action required) the address editor tab. This shows the addresses of the memory-mapped peripherals / interfaces. We have two corresponding to AXI (mentioned as S_AXI_FULL) and AXI Lite (S_AXI) interfaces of the AXI Stream FIFO. You can edit the addresses and ranges if you wish, but unless you have a good reason to (or if you are into numerology), it is fine to leave it as such.</p> <p></p> <p>We are done with the block design. Save the block design (Ctrl+S).</p> <p>Synthesis tools can't synthesize a block design directly. We need to convert the block design into HDL. Under Sources &gt; Design Sources, right-click the .bd file and select 'Create HDL Wrapper'.\u00a0</p> <p></p> <p>Accept the default, i.e., let 'Vivado manage ...' and click OK.</p> <p>Now click 'Generate Bitstream' and OK.</p> <p>Once it is done, File &gt; Export &gt; Export Hardware &gt; Next &gt; Change to Include Bitstream.</p> <p>Next &gt; (note the path, the default is the project directory itself)&gt; Next &gt; Finish.</p> <p>For the various steps such as synthesis/implementation etc,\u00a0 setting the number of jobs equal to the number of cores (maximum in the drop-down list) may cause it to complete faster, esp on Linux. Often, the number appearing by default is 4, which can be changed to a higher number. If you have other programs running in the background, set it to the maximum value in the list minus one or two.</p> <p>Continue to the instructions for software development using Vitis.</p>"},{"location":"Lab_2/3_Using_Vitis_Classic/","title":"Software development using Vitis Classic","text":"<p>This page details the steps involved in creating a software application using Vitis, an Eclipse-based IDE, to run on the hardware platform created using Vivado. You should be using a Vitis version that matches your Vivado version.</p> <p>Note: There are slight differences in GUI and options based on the version. The spirit of what is being done remains the same.</p>"},{"location":"Lab_2/3_Using_Vitis_Classic/#vitis-classic","title":"Vitis Classic","text":"<p>Open the VItis IDE from the start menu or by clicking the desktop icon. Do NOT start from Tools &gt; Launch Vitis IDE from Vivado, as it will launch VS Code based IDE, which we won't be using for now.</p> <p>Give a workspace path. This can be any folder, though it might a good idea to create it under \\workspace, so that the hardware and software projects are in the same folder.\u00a0 <p>This will bring up the IDE. Click Create Platform Project (or File&gt;New&gt;Platform Project).</p> <p>Note: It is also possible to start from Create Application Project, which will prompt you to select/create a Platform Project. You can also choose Create Application Project later, to create applications such as a simple Hello World application.</p> <p>You will get a new platform project dialog. Enter a name for your project, and click Next.</p> <p>In the next screen, click on the Create a new platfo.... (XSA) tab. The click the Browse button. A file selector window will open, where you will have to navigate to\u00a0 and select the design_1_wrapper.xsa file.\u00a0\u00a0It will take a few seconds to read the .xsa file. Accept the defaults*. While making sure that the correct .xsa is selected, click Finish. <p></p> <p>*OS=standalone, Processor=psu_cortexa53_0, Generate boot components (First Stage Boot Loader aka FSBL) checked, etc. If you fancy playing with FreeRTOS (which gives you support for multithreading etc.), you can choose that, though for EE4218, standalone (a library providing basic functions such as stdin/stdout used by prinft/scanf and some other basic functionalities for 'bare metal' programming) is good enough. You can uncheck the Generate boot components option - this will, however, cause an error to be flagged every time you build anything. While this shouldn't affect our functionality, if this can be annoying to you, you can leave it checked. The run configuration (later) is slightly different based on whether you leave it checked or uncheck it. Also, the non-FSBL initialization is generally more prone to random issues such as the debugger hanging.</p> <p>You will now be presented with the workspace. Under the platform project, click on platform.spr. Click on Board Support Package under standalone on psu_cortexa53_0. You can now modify BSP settings if need be (though defaults should be fine), such as including various libraries, selecting the drivers to be used for various peripherals, selecting the std_in and std_out peripherals (which should both be psu_uart1), etc.</p> <p>You can import examples for the various peripherals. For a start, we can run an example program for psu_uart1, which is the peripheral we will be using for basic input/output (and will interact with the serial console program, e.g., RealTerm).</p> <p></p> <p>In the next screen, select xuartps_hello_world_example. You will now see the application project in the workspace.</p> <p></p> <p>Have a look at the main source file, and understand the code.</p> <p>Now, click build to build the application. If need be, build the platform project (select the platform project and click build) before building the application.</p> <p></p> <p>Once the build has been completed, we can run the program. For this, we need to create a Run Configuration.\u00a0\u00a0</p> <p>Click the drop-down button next to Run, and click Run Configurations.</p> <p></p> <p>Double click Single Application Debug, and you will see a Debugger_xuartps_hello_... under it. \u00a0In the Application tab (next to the Main tab), make sure that the\u00a0Project, as well as Application fields, are populated. If not, click Browse and select the Project; click Search and select the .elf file.</p> <p></p> <p>Configure Target Setup as follows, depending on whether you checked 'Generate Boot Components' (aka FSBL) in an earlier step or not.</p> <p>Using FSBL -</p> <p></p> <p>Not using FSBL - more prone to debugger hanging. This can be used even when FSBL is included in the platform project.</p> <p></p> <p>Make sure that you connect the micro USB cable to your computer and the board. Make sure that the board is powered on via the adaptor (it is not powered via USB). RealTerm should be opened and the correct port number should be selected (the lowest numbered among the multiple COM/ttys detected corresponding to the board).</p> <p>Once that is done, you can click\u00a0Apply and then Run. If an Overwrite Boot Mode warning appears, click Yes.</p> <p>If you are getting errors such as \"Could not find ARM device...\", the board is likely not detected - either the board is not powered on, or the cable is not connected, driver is not installed, or you did not allow some firewall warning during installation or first run. Check if you can program the FPGA (not run the program) by going to Vitis (in Eclipse IDE top menu) &gt; Program Device &gt; Program (after ensuring that a valid bitstream is present for the Bitstream/PDI field). If it gives the same error, it is certainly about your board not being detected.</p> <p>If you get this error - \"Error while launching program: Memory write error at 0x0. Cortex-A53 #0: EDITR not ready\", run the following commands in the XSCT Console (bottom right in Debug perspective*) in Vitis Classic. This will set the boot mode to JTAG, which is what we want. This may need to be done once everytime the board is powered on.</p> <p></p> <p>targets -set -nocase -filter {name =~ \"*PSU*\"} mwr 0xff5e0200 0x0100 rst -system</p> <p>References:</p> <p>https://support.xilinx.com/s/question/0D52E00006pW5zTSAS/error-memory-write-error-at-0x0-cortexa53-0-editr-not-ready-when-trying-to-debug-using-platform-cable-ii?language=en_US https://xilinx.github.io/kria-apps-docs/creating_applications/2022.1/build/html/docs/bootmodes.html</p> <p>*You can switch perspectives from Window &gt; Debug Perspective to go to debug, and\u00a0Window &gt; Design Perspective\u00a0to see Explorer, files, etc. You can also switch perspectives easily by selecting the required perspective on the top right as shown below.</p> <p></p> <p>For future runs until you disconnect the FPGA (or until you update the bitstream using Vivado), you can uncheck 'Reset Entire System' and 'Program FPGA, and click Apply. Otherwise, the FPGA will be re-programmed every time you run a program, which is not necessary. You can also leave these two options permanently unchecked if you program the FPGA through Xilinx Tools -&gt; Program FPGA.</p> <p>You should now be able to see the Hello World printed on RealTerm console (the exact message will be different).\u00a0</p> <p></p> <p>You can run again without opening up the Run configurations window by simply clicking the Run button as shown below.</p> <p></p> <p>Debugging can also be done to run step by step and inspect the variable values etc. You can also set breakpoints and all other debugging features. The same run configuration created above can also be used for Debug, you just need to click the Debug button.</p> <p></p> <p>It should automatically change perspective to Debug Perspective. If it prompts you if you want to go ahead, click OK. The program is now suspended at the first line of the main() function as shown below. You can use the standard debugging controls such as Resume, step over, step into, etc.\u00a0</p> <p></p> <p>Vitis does not auto-build before running/debugging. If you had changed your program, remember to build it before you debug / run it.</p> <p>Once done, Disconnect button in the Debug Perspective - either of the two places highlighted in the figure below. If this is not done, you may get a warning that a debug is ongoing.</p> <p></p>"},{"location":"Lab_2/3_Using_Vitis_Classic/#beyond-hello-world-running-axi-stream-fifo-example-program","title":"Beyond Hello World : Running AXI Stream FIFO Example program","text":"<p>Go to drivers, and select the example for axi_fifo_mm_s_0 as shown in the figure below. This assumes a loopback connection in the block diagram / design we created in Vivado.</p> <p></p> <p>Run and see the results, which should show a success message in the Serial (UART) console.</p>"},{"location":"Lab_2/3_Using_Vitis_Classic/#optional-exercise","title":"Optional Exercise","text":"<p>Simple input/output : Write a simple program in Vitis to read a character from the console and print that character to the console (echo).</p> <p>Essentially, you sent out a character from RealTerm console to PSU_UART1 on the Kria board. The C program running on ARM Cortex A53 reads it from the PSU_UART1 input buffer (using scanf or UART driver functions), and writes it to the PSU_UART1 output buffer (using printf or UART driver functions). The PSU_UART1 will send it over to the RealTerm console, which will then display it.</p>"},{"location":"Lab_2/4_Serial_Console/","title":"Serial Console - RealTerm","text":"<p>Note: See the last tip in Introduction to Hardware/Software Co-design page for an important tip.</p> <p>RealTerm is a terminal program specially designed for capturing and sending data through various protocols (UART, Raw TCP sockets etc). The purpose is similar to that of TeraTerm or PuTTY or GTKTerm or Serial Monitor (Arduino), but RealTerm is WAAY more feature-rich than any other serial console program.</p> <p>The program can be downloaded from\u00a0https://realterm.i2cchip.com/Realterm_3.0.1.44_setup.exe. Older versions are fine too. The newer versions have more options and look slightly different from the screenshots on this page.</p> <p>If you are using FPGA locally, you need to configure the correct port and baud\u2010rate (115200) in RealTerm. This is shown in the figure below. Please ensure that Change is clicked after any port/speed modification.</p> <p></p> <p>The next step is to open the port. Click on Open to open the port. The status on the right should be green or gray, not red.</p> <p></p> <p>Note: Ensure that the port you are trying to connect to in RealTerm is not selected in Vitis.</p>"},{"location":"Lab_2/4_Serial_Console/#few-notes-on-the-usage-of-realterm","title":"Few notes on the usage of RealTerm","text":"<p>Sending bytes using RealTerm: Click on the Send tab, type a number and click Send Numbers/Send ASCII. If you input, say 20 there and press Send Numbers, it will send 0x14. You can also enter directly as hexadecimal 0x14 and press Send Numbers.</p> <p>If you enter 20 press Send ASCII, it will send two characters 0x32 and 0x30. If you enter 0x14 and press Send ASCII, it will send 4 characters 0x30, 0x78, 0x31, 0x34 .</p> <p>You can also use escape sequences (special characters) such as \\r, \\n etc.</p> <p></p> <p>Sending text file contents using RealTerm: Specify the file in the Dump File to Port and click Send File.</p> <p></p> <p>Capturing data into a file using RealTerm: Click on Capture tab and specify the file where you want the output to be saved. Click on Start Overwrite.\u00a0 Check the Display option (available only in the newer versions) if you wish to see the data that is getting captured.</p> <p></p> <p>Explore the various features of RealTerm\u00a0and be familiar with it.</p> <p>The data can be displayed in a number of different formats, selectable from the Display tab.</p> <p>You can also click on the black part of the screen to send what you type, similar to how it is in TeraTerm/PuTTY etc. You can enable 'Half Duplex' in the Display tab if you like to see what you send out in a different color (green). The received data will be in yellow color.</p> <p>You can enable newLine mode if you wish the incoming formatting characters such as \\n to work as intended, instead of simply displaying it - RealTerm displays \\n as lf (linefeed) and \\r as cr (carriage return).</p>"},{"location":"Lab_3/1_IntegratingCoPro/","title":"Integrating the Coprocessor","text":"<p>Try out Coprocessor Packaging and Integration using AXI Stream FIFO using the original template coprocessor provided in Lab 1 first, before using your version of the Lab 1 coprocessor.</p> <p>Once you have gotten it to work, please attempt the assignment below.</p>"},{"location":"Lab_3/1_IntegratingCoPro/#assignment-3","title":"Assignment 3","text":"<p>The assignment essentially involves combining Lab 1 and Lab 2, such that the data can be streamed from RealTerm to the C code running on ARM Cortex A53, the processing is done in hardware using the coprocessor, and the results are sent back to RealTerm. You can optionally do the processing in software (C) and compare the results, but the results have to be sent back to the console.</p> <p>Please follow the following procedure.</p> <ul> <li>Change your Lab 1 HDL code to accommodate the bigger matrix sizes for A, B, and RES (64x8, 8x1, and 64x1 respectively).</li> <li>Test it thoroughly (behavioral simulation as well as\u00a0post-synthesis functional simulation) using a well-designed testbench. You will have to modify the .mem files and the testbench to deal with the bigger matrix. Some other cases were not tested by the Lab 1 testbench, such as the non-continuous assertion of S_AXIS_TVALID and M_AXIS_TREADY. Hopefully, these should be fine in your design. AXI FIFO is unlikely to do a non-continuous assertion of these signals, whereas some other peripherals such as AXI DMA are likely to.</li> <li>Now, integrate this coprocessor using the same procedure you had followed for the original Lab 1 template coprocessor.\u00a0 You might want to have a look at the Modifying the Coprocessor page to see how to re-package your modified coprocessor. You will have to modify test_fifo_myip_v1_0.c file as appropriate. You will need to have either the Transmit FIFO Depth of AXI Stream FIFO set to 1024 (in Vivado), or send it over two transmit operations in C code to send more than 512 words. The first approach will take more hardware but takes less time to send the full data over.<ul> <li>Initially, hard code the test cases.</li> <li>Later, you should modify it to deal with the data streamed from RealTerm, just as you did for Lab 2.</li> </ul> </li> <li>An even better way to wait until the coprocessor responds would be to use interrupts. This requires the AXI FIFO interrupt output to be connected appropriately, with appropriate changes to the program.</li> <li>Use the Vitis built-in debugger (TCF-based) to step through your software code, and inspect what is happening at each step, to ensure that the data sent to the co-processor is correct, as well as to inspect the value received from the coprocessor.</li> <li>Implementation using AXI DMA is NOT a requirement. However, it is strongly suggested that you try it out. Even if you are not trying it out, you are expected to understand how it works and how it is done.</li> </ul> <p>Submission Info</p> <p>Assignment 3 (7 marks)</p> <p>Demonstrate in\u00a0week 7.</p> <p>Upload</p> <p>Upload an archive containing only the files you have created/modified such as</p> <ul> <li>.xsa file</li> <li>.c/.h</li> <li>.v/.vhd RTL and testbench</li> <li>.xdc file (only if you manually inserted/modified any constraints)</li> <li>input/output test files - the .mem files as well as the files sent/received from/by RealTerm (if you modified them)</li> </ul> <p>exactly as used for the demo to the Canvas by 11:59 PM,\u00a07th March 2024.</p> <p>It should be as a .zip archive, with the filename \u00a0__3.zip. <p>Please\u00a0DO NOT\u00a0upload the whole project - include only the files mentioned above!</p>"},{"location":"Lab_3/1_IntegratingCoPro/#tips","title":"Tips","text":"<ul> <li>Debugging in Lab 3 is hard. It is your hardware, interacting with your software. It is hard to identify and isolate issues.<ul> <li>You can check the software functionality by setting breakpoints just before sending data to the coprocessor / just after receiving the data from the coprocessor.</li> <li>If the software appears to be ok, then it is likely your hardware. This can be<ul> <li>A missing connection in the block diagram -\u00a0 'Validate Design' running ok does not guarantee everything is ok. It only checks for some very essential stuff, which might not be good enough for proper functionality.</li> <li>The IP not being updated. Changing the HDL code alone is not sufficient. You need to repackage the IP (see the last part of Packaging the Coprocessor as an IP page to know how to do this). Then try regenerating sources. Worst come to the worst, package the IP afresh.</li> <li>A functional issue with your co-processor. This typically involves not asserting\u00a0M_AXIS_TLAST and\u00a0M_AXIS_TVALID correctly, and not dealing with\u00a0M_AXIS_TREADY properly. Some possible reasons:<ul> <li>If you don't get a response from the co-processor, check if M_AXIS_TLAST is asserted properly.\u00a0</li> <li>If it doesn't respond with the correct amount of data, it could be\u00a0M_AXIS_TLAST getting asserted at the wrong time.</li> <li>If it responds with incorrect data, check the correspondence between\u00a0M_AXIS_TVALID and\u00a0M_AXIS_TDATA.</li> <li>Verify these using\u00a0post-synthesis functional simulation, not just using behavioral simulation.</li> </ul> </li> </ul> </li> </ul> </li> <li>You will possibly get a critical warning: \"[Timing 38-282] The design failed to meet the timing requirements. Please see the timing summary report for details on the timing violations.\".<ul> <li>This is not a warning that you should normally ignore. The timing analysis tool is complaining that the design may not work at 100 MHz, i.e. has a critical path greater than 10 ns (possibly in multiplication). You can look at the timing summary and figure out which path causes it to fail the timing. You can then see how this can be fixed, which will involve some design modifications.</li> </ul> </li> </ul>"},{"location":"Lab_3/2_FIFO/","title":"Coprocessor Integration using AXI Stream FIFO","text":"<p>You can read more about AXI Stream FIFO at https://www.xilinx.com/support/documentation/ip_documentation/axi_fifo_mm_s/v4_1/pg080-axi-fifo-mm-s.pdf (please do!)</p> <p>When we use AXI Stream FIFO as the bridge, the processor reads the operands from the memory (RAM) and writes them to the transmit FIFO in AXI Stream FIFO peripheral via AXI (not AXI Stream), which in turn passes it to the coprocessor via AXI Stream. The result returned by the coprocessor gets deposited into a receive FIFO in AXI Stream FIFO peripheral, from which the processor reads it via AXI (not AXI Stream) and writes it to the memory (RAM).</p> <p>This manual assumes that we are using the custom IP created using the coprocessor template given for Lab 1 for adding 4 numbers. It has two AXIS interfaces - S_AXIS for sending data, and M_AXIS for receiving data. Even if the coprocessor functionality is different, the interface is still the same, and hence the procedure below applies.</p> <p>Let us assume you are starting with your Lab 2 Vivado project as shown below, with the AXI Stream FIFO peripheral already included. If not, include AXI Stream FIFO following the instructions in Lab 2. Also, note that the connection from the interrupt of axi_fifo_mm_s_0 to pl_ps_irq0 of zynq_ultra_ps_e_0 is optional, only if you want to use interrupts.</p> <p>The following instructions also assume that the coprocessor is already added/available in the IP Integrator canvas. If not, add it from the IP Catalog.</p> <p></p> <p></p> <p>Now, make/modify the following connections.</p> <p>Delete the connection from axi_fifo_mm_s_0/AXI_STR_TXD to axi_fifo_mm_s_0/AXI_STR_RXD</p> <p>Connect myip_0/M_AXIS &lt;-&gt; axi_fifo_mm_s_0/AXI_STR_RXD</p> <p>Connect myip_0/S_AXIS &lt;-&gt; axi_fifo_mm_s_0/AXI_STR_TXD</p> <p>You can now run the connection automation that will connect the ACLK and ARESETN of myip_0 :</p> <p>myip_0/ACLK &lt;-&gt; zynq_ultra_ps_e_0/pl_clk0</p> <p>myip_0/ARESETN &lt;-&gt; rst_ps8_0_99M/peripheral_aresetn</p> <p>You can click regenerate layout to tidy up.</p> <p></p> <p>You can now save the block design (Ctrl+S) and generate bitstream.</p> <p>The rest of it is similar to Lab 2.</p> <p>You need to export hardware including bitstream.</p> <p>Open Vitis Classic &gt; create a new workspace (using the previous one is also ok) &gt; create a new platform project using the new .xsa file (upgrading the previous one is ok too), &gt; create an application project.</p> <p>The application project (say, Hello World) main file contents should be replaced by test_fifo_myip_v1_0.c to test the coprocessor for adding numbers. Note the close parallel it has with\u00a0tb_myip_v1_0.v/vhd.\u00a0You can make appropriate changes to this file to deal with different input and output sizes if your coprocessor functionality is different.\u00a0</p> <p>Now, create a run configuration, open the serial console program (e.g., RealTerm), and run.</p> <p>If you wish to use interrupts, you need to make sure that there is a connection from the interrupt of axi_fifo_mm_s_0 to pl_ps_irq0 of zynq_ultra_ps_e_0. There is a built-in example program for axi_fifo_mm_s using interrupts, which can be combined appropriately with test_fifo_myip_v1_0.c to have interrupt-based communication. However, note that interrupts are useful only if the processor is doing some other meaningful work while the coprocessor is doing computations.</p>"},{"location":"Lab_3/3_DMA/","title":"Coprocessor Integration using AXI DMA","text":"<p>In this manual, you will learn to integrate the AXIS coprocessor using AXI Direct Memory Access (DMA) instead of AXI FIFO. We will use the simple AXIS coprocessor designed in Lab 1 (and packaged in Lab 3) or the one created and packaged using HLS in Lab 4. In any case, it is a good idea to have the functionality tested using AXI Stream FIFO first.</p> <p>When using AXI DMA, the processor only supplies (via AXI Lite, not AXI Stream) the starting address and the size/amount of data to be transferred from the memory to the coprocessor (or vice versa), and it is the DMA controller that reads memory directly and passes it to the coprocessor via AXI Stream (or vice versa). The processor is not involved in the transfer of data directly, i.e., it does not do repeated load-store (LDR-STR in ARM terminology) to do bulk data transfer.</p> <p>We will be using the Xilinx AXI DMA IP as the module that connects the coprocessor to the rest of the system. You can find the specification of AXI DMA here:\u00a0http://www.xilinx.com/support/documentation/ip_documentation/axi_dma/v7_1/pg021_axi_dma.pdf</p> <p>You can start with a new project, or from the existing project. Since most of you would be reaching this step from the existing project which would have the coprocessor connected using AXI Stream FIFO. In the future, if you are starting a new project and plan to use AXI DMA, you need not have AXI Stream FIFO in your design at all. It is also fine to delete AXI Stream FIFO from the project (instructions later), which can save some hardware and synthesis time. On this page, however, we keep the AXI Stream FIFO and connect it in loopback mode, rendering it vestigial.\u00a0</p> <p>The following instructions also assume that the coprocessor is already added/available in the IP Integrator canvas. If not, add it from the IP Catalog.</p> <p></p> <p></p> <p>Now, make/modify the following connections of AXI Stream FIFO.</p> <p>Delete myip_0/M_AXIS &lt;-&gt; axi_fifo_mm_s_0/AXI_STR_RXD connection.</p> <p>Delete myip_0/S_AXIS &lt;-&gt; axi_fifo_mm_s_0/AXI_STR_TXD connection.</p> <p>Make a connection from axi_fifo_mm_s_0/AXI_STR_TXD &lt;-&gt; axi_fifo_mm_s_0/AXI_STR_RXD. This will make the AXI Stream FIFO in loopback mode and hence useless.</p> <p>Alternative: Delete the AXI Stream FIFO peripheral altogether. This can be done by simply selecting the block via single-click and pressing delete (or from the right-click menu). If you do so, you need to double-click the AXI Interconnect and reduce the number of Master interfaces by 1; e.g., if it was originally 3, we need to make it 2; if it was originally 2, we need to make it 1. This is because the AXI Stream FIFO peripheral has two AXI slave interfaces (S_AXI and S_AXI_FULL, as we enabled AXI as well in addition to the original AXI Lite interface), whereas AXI DMA requires only one AXI slave interface (S_AXI_LITE).</p> <p>This can cause some existing AXI slave connections to be broken (e.g., M0x_AXI of the AXI Interconnect to S_AXI of the peripheral), which can be easily fixed by obliging to the connection automation prompt.</p>"},{"location":"Lab_3/3_DMA/#connecting-the-coprocessor-using-dma","title":"Connecting the Coprocessor using DMA","text":"<p>From the IP catalog, add the peripheral titled AXI Direct Memory Access. Double-click it,\u00a0uncheck\u00a0Enable Scatter Gather Engine, and click OK. It will look like the figure below.</p> <p></p> <p>The\u00a0S_AXI_LITE\u00a0is the AXI-Lite slave interface that receives the commands (how much data is to be transferred from/to which address etc) from\u00a0the ARM core in PS. Running connection automation will connect it, as well as the s_axi_lite_aclk and axi_resetn.</p> <p>MM2S : When data has to be transferred to the coprocessor, the ARM core specifies the range of memory (starting address, size of data to be sent) to the DMA peripheral by writing to the DMA peripheral registers through the S_AXI_LITE interface. The DMA controller reads the memory via M_AXI_MM2S interface (this is the AXI master interface which has only read\u00a0channels), and sends the data to the\u00a0S_AXIS of the coprocessor via the M_AXIS_MM2S.</p> <p>S2MM : When data has to be received from the coprocessor, the ARM core specifies the range of memory (array starting address, length of data to be received) to the DMA peripheral by writing to the DMA peripheral registers through the S_AXI_LITE interface. The DMA controller receives the data from M_AXIS of the coprocessor via the S_AXIS_S2MM, stores it in an internal buffer, and then writes it to the memory via M_AXI_S2MM interface (this is the AXI master interface which has only write\u00a0channels).</p> <p>First, make the M_AXIS_MM2S &lt;-&gt;S_AXIS and M_AXIS &lt;-&gt; S_AXIS_S2MM connections to connect the coprocessor/myip and the DMA.\u00a0You can now run connection automation, which will connect ACLK and ARESETN of myip.</p> <p>The DDR memory controller is implemented in the PS, which requires a slave AXI interface in PS to receive the address and read/write commands from the AXI DMA master interfaces, i.e., M_AXI_S2MM and M_AXI_MM2S. For this, we need to enable one of the Slave Interface &gt; AXI HP (let's say, AXI LPD) in the PS-PL configuration of the Zynq Ultrascale+ MPSoC IP/zynq_ultra_ps_e_0. Double click the Zynq PS IP &gt; PS-PL Configuration&gt; Slave Interface &gt; AXI HP &gt; AXI LPD and then OK. A new interface called S_AXI_LPD will appear on the Zynq Ultrascale+ MPSoC IP block diagram in the IP Integrator canvas.</p> <p></p> <p>We now need to connect M_AXI_S2MM and M_AXI_MM2S to S_AXI_LPD. This will have to be done using an AXI Interconnect or AXI SmartConnect. This can be done through connection automation twice. When you run the connection automation once, it will make only one connection - M_AXI_MM2S\u2192 S_AXI_LPD (if M_AXI_MM2S is selected in Options &gt; Master Interface in the connection automation dialog), and the corresponding m_axi_mm2s_aclk. The connection automation banner will still be there. Run connection automation again. This time, it will add an interconnect and make the M_AXI_S2MM\u2192 S_AXI_LPD, as well as the m_axi_s2mm_aclk connection.</p> <p>*Note: AXI Interconnect and AXI SmartConnect are functionally similar. The latter is newer and more optimized, though the connection automation does not always include it.\u00a0</p> <p>Overall, the connections should be as shown below, at least those relevant to AXI DMA. There could be differences in the overall block design and connections depending on the exact peripherals you have in the design.</p> <p></p> <p>Have a look at the Address Editor tab too. It should generally be fine as long the AXI (not AXIS - AXIS connections were done manually anyway and have no concept of addresses/memory map) connections are done via connection automation. If there were any manual modifications you made to AXI connections, appropriate manual modifications may be needed here.</p> <p>In particular, ensure that in which zynq_ultra_ps_e_0 is the master, all S_AXIs are given proper, non-conflicting addresses. Also, ensure that in the network where axi_dma_0 is the master, S_AXI_LPD with the slave segment LPD_DDR_LOW is included (i.e., not excluded) for both axi_dma_0/Data_MM2S as well as axi_dma_0/Data_S2MM. This is to ensure that the AXI DMA peripheral can read as well as write (respectively) the DDR memory.</p> <p></p> <p>We are done with the block design.\u00a0</p> <p>The rest of it is pretty standard and you should know the drill by now.</p> <p>Export hardware including bitstream.</p> <p>Open Vitis Classic &gt; create a new workspace (using the previous one is also ok) &gt; create a new platform project using the new .xsa file (upgrading the previous one is ok too), &gt; create an application project.</p> <p>The application project (say, Hello World) main file contents should be replaced by test_dma_myip_v1_0.c\u00a0to test the coprocessor for adding numbers. Note the close parallel it has with\u00a0tb_myip_v1_0.v/vhd and test_fifo_myip_v1_0.c.\u00a0You can make appropriate changes to this file to deal with different input and output sizes if your coprocessor functionality is different.\u00a0</p> <p>Now, create a run configuration, open the serial console program (e.g., RealTerm), and run.</p> <p>If you wish to use interrupts, you need to make sure that there is a connection from the interrupt of s2mm_introut or mm2s_introut to pl_ps_irq0 of zynq_ultra_ps_e_0. There is a built-in example program for axi_fifo_mm_s using interrupts, which can be combined appropriately with test_dma_myip_v1_0.c to have interrupt-based communication. However, note that interrupts are useful only if the processor is doing some other meaningful work while the coprocessor is doing computations. If you want to use both s2mm_introut and mm2s_introut or have more than one peripheral with interrupts, you will need to enable more PL-PS interrupts in the Zynq Ultrascale+ MPSoC IP/zynq_ultra_ps_e_0 block configuration, under PS-PL settings.</p> <p>The built-in (BSP) example (simple poll) works too with appropriate modifications, but it uses hard-coded addresses and uses memory locations without allocating memory in the code. Cache-related stuff becomes quite messy if the invalidation has side effects, that is, other variables in the same cache block getting affected. So keeping it away from the range of memory used by the rest of the program is a reasonably good choice, though this kind of memory allocation will make a memory safety advocate cringe (but ok considering that user-level programs typically do not do DMA directly - it is typically an OS function).</p> <p>Debugging tip: DMA in a system with cache enabled gives several headaches. Throw interrupts into the mix, and you could run into some hard-to-debug issues. One simple starting point in debugging DMA-related issues is to uncomment Xil_DCacheDisable(). If things work, the issues are cache-related. Of course, you wouldn't want to leave the cache disabled in a real-world system for performance reasons, but it would be a good first step in debugging DMA-related issues.</p>"},{"location":"Lab_3/3_DMA/#axi-dma-vs-axi-stream-fifo","title":"AXI DMA vs AXI Stream FIFO","text":"<p>AXI DMA implemented this way, while still likely faster than AXI Stream FIFO, won't be making full use of\u00a0 DMA's potential. In our case, the CPU is doing nothing while waiting for the DMA transfer to finish. In a more real-life scenario, the CPU will execute something else (another thread) in the meantime using the data present in the cache, or through some form of intermittent memory access - read here. The thread that is waiting for the DMA transfer to complete will be woken up only when the DMA controller raises an interrupt to signal to the CPU that the transfer is complete.</p> <p>Another couple of questions to ponder:</p> <ul> <li>AXI DMA does not need a buffer (and certainly not a big internal buffer), unlike AXI Stream FIFO. Why?</li> <li>AXI DMA has an AXI LITE interface, whereas AXI Stream FIFO should have a full AXI interface for performance reasons. Why?</li> </ul>"},{"location":"Lab_3/4_ModifyCoPro/","title":"Modifying the Coprocessor","text":"<p>Changing the HDL file for the co-processor alone isn't usually sufficient to ensure the changed functionality. Creating a custom IP all over again using the new HDL file isn't necessary either.</p> <p>Right-click on the custom IP in the block design, and choose\u00a0Edit in IP Packager. This will open up a Vivado Project. Change the co-processor functionality here. Click\u00a0the\u00a0Package\u00a0IP\u00a0in\u00a0the\u00a0Flow\u00a0Navigator. Since we aren't changing interfaces, all we need to do is to click\u00a0Re-Package IP\u00a0in Review and Package.</p> <p>Once you come back to your main Vivado project, it will show a banner that 'IP Catalog is Out of Date' or 'myip_0 should be upgraded'. If it is the former, click\u00a0Rerun\u00a0in the IP Status Tab below. If it is the latter, clicking Report IP Status / Show IP Status will open up the IP Status Tab. Either way, after myip_0 is selected, click\u00a0Upgrade Selected.</p> <p>If the 'IP Status' tab does not appear, make sure that the IP Integrator is selected in the Flow Navigator, and Reports (top menu bar) &gt; Report IP Status.</p> <p>An IP Upgrade Completed will pop up once the IP is successfully upgraded.\u00a0When you dismiss the message by clicking OK, it will show up a Generate Output Products window.\u00a0Click\u00a0Generate. Once the output products are generated, click OK to dismiss the message.\u00a0 The IP Status will again show that one or more IPs have changed. Click\u00a0Rerun\u00a0again (the second time is for regenerating reports), but you need not (and won't be able to) click Upgrade Selected this time.</p> <p>You can check if the IP is updated by following the screenshot below.</p> <p></p> <p>Now, you can go ahead and\u00a0Generate Bitstream.</p> <p>Once the hardware is generated, Export &gt;\u00a0Export Hardware. Don't forget to\u00a0Include bitstream.</p> <p>The SDK will pop up a window/warning regarding Hardware Specification FIle Change. Click\u00a0Yes\u00a0to continue and wait for your BSP and project to be rebuilt.</p> <p>For Vitis, you have to do it explicitly by right-clicking on the hardware platform as shown in the figure below. You will then be required to browse to the updated .xsa file, followed by two OKs.</p> <p></p> <p>Then build the design_1_wrapper.</p> <p></p> <p>Change your C code if/as necessary and then build your application project. If you get errors about fsbl, you can ignore it as long as the .elf corresponding to your application is successfully built.\u00a0(FSBL = first stage boot loader, needed only if you are planning to boot from SD card. In our case, the program is loaded by the debugger hardware, so we don't have to bother.).\u00a0</p> <p>The Vitis project doesn't always get updated that properly. If you run into issues, Reset BSP Sources as shown in the figure below, and build the hardware and application projects.</p> <p></p> <p>If that doesn't work either,\u00a0create a new workspace, and then an application project using the new .xsa file. Copy over your C code to the new project.</p> <p>Don't forget to\u00a0program the FPGA again\u00a0before running your code (which will be done automatically if the option to Program FPGA is checked in Run Configurations), as the hardware has now changed!</p> <p>If it still shows the old coprocessor functionality, perhaps you did not repackage the IP properly. If you are sure you did, you might want to try deleting intermediate files in Vivado and regenerating the bitstream.</p>"},{"location":"Lab_3/5_PackagingIP/","title":"Packaging Coprocessor as an IP","text":"<p>The following procedure describes how the coprocessor of Lab 1 can be packaged as an IP which can be used in the IP Integrator. A more tedious alternative will be to make the connections yourself using HDL in the wrapper.</p> <p>There could be slight differences in what you see based on the version of Vivado, but the spirit of the instructions below remains the same.</p> <p>We can continue from the hardware platform project from Lab 2 as shown below. You could also package the IP in a separate project rather than in the Lab 2 project. The packaged IP can be imported into the project you want it in (e.g., the Lab 2 project). Either way, the steps for packaging are the same.</p> <p>The exact block diagram will vary for you depending on whether or not you included other peripherals for Lab 2 (e.g., AXI Stream FIFO, AXI Timer), but does not fundamentally change how you package the coprocessor as an IP - the exact peripherals and connections can be changed later.\u00a0</p> <p></p> <p>Select\u00a0Tool (Vivado top menu) \u2192 Create and Package IP. The Create and Package IP dialog will appear.\u00a0Click\u00a0Next.</p> <p>Select\u00a0Create a New AXI4 Peripheral and\u00a0Next, you may use the default settings.\u00a0Next\u00a0again.</p> <p>You will now be presented with an interface. It is entirely possible to configure this page properly (e.g., by choosing Stream, Slave, and then adding a Stream, Master) and get a template for an AXI Stream co-processor. However, the template provided is rather complex. So we will be just using the lab 1 template rather than relying on the template generated by Vivado. So we just accept the defaults (which is a peripheral with an AXI Lite slave interface) and click Next\u00a0and Finish.</p> <p>Now\u00a0we\u00a0can\u00a0add\u00a0our\u00a0custom\u00a0IP\u00a0to\u00a0the\u00a0design.\u00a0Choose\u00a0Add IP (the + button in the IP Integrator canvas, or right-click anywhere on the canvas and Add IP) and search for myip. If\u00a0myip_v1_0 (the coprocessor) is not available in the IP catalog, it means the custom IP folder is not local to the project, and you need to add the folder containing it to the IP repository. This can be done by right-clicking on the IP integrator canvas, IP settings &gt; IP &gt; Repository.</p> <p>Do NOT make any connections to the added IP as yet.</p> <p>We need to modify our custom IP. Right-click on the block, and select Edit\u00a0in\u00a0IP\u00a0Packager.\u00a0Vivado will create another Vivado project to edit the IP just like the one you worked on in Lab 1. The default location will be inside your project folder, .tmp folder. Click OK. <p>Remove myip_v1_0_S00_AXI.v/vhd (Right-click and 'Remove File from the Project'). Copy-paste the content of myip_v1_0.v/vhd from the original Lab 1 template to overwrite the Vivado-created myip_v1_0.v/vhd contents.</p> <p></p> <p>Now, right-click Design Sources &gt; Add Sources &gt; Add or create design sources &gt; Next &gt; Add Files &gt; Browse to and select matrix_multiply.v/vhd and memory_RAM.v/vhd, from the original Lab 1 templates. Check the option 'Copy sources into IP directory' and uncheck 'Scan and add RTL include files into project' (this will keep the files in the IP directory, which is a good idea) &gt; OK &gt; Finish.</p> <p>Note: It is also ok to remove the auto-generated myip_v1_0.v/vhd and add myip_v1_0.v/vhd along with matrix_multiply.v/vhd and memory_RAM.v/vhd. However, Vivado will ask for a top-level module when both the auto-generated files are removed which you can dismiss by accepting the default selection and clicking OK. In the future, when you wish to modify the original files, it is better to replace the original contents with the new contents rather than remove the file altogether and then add back the updated version.</p> <p>Make sure that myip_v1_0 is the top module, if it is not picked up automatically. The design sources folder should look like how it was for Lab 1.</p> <p>We now have to reconfigure the IP configurations to allow the original Vivado project to recognize the new IP interfaces correctly. You can notice that some of the green check marks that were originally there are now gone from the Package IP - myip tab (if you closed the tab, it can be reopened from Design Sources &gt; IP-XACT &gt; component.xml), under Packaging Steps.\u00a0Here, select File Groups, and click Merge changes from File Groups Wizard.</p> <p></p> <p>Now click Customization Parameters, and click 'Merge changes ...'.. Right-click and remove C_S00_AXI_BASEADDR and C_S00_AXI_HIGHADDR \u00a0(this is a vestige of our original selection of a AXI memory-mapped slave as the IP).</p> <p>Now click Ports and Interfaces, and click 'Merge changes ...'.</p> <p>Select the 4 signals starting with S_AXIS (via Ctrl+click or Shift+Click). Right-click and select Auto Infer Interface. In the dialog that opens up, select AXI &gt; axis_rtl and click OK.</p> <p></p> <p>In the next dialog, the name S_AXIS will be autodetected (you can change the name if you wish), and verify that the Mode is salve. Click OK.</p> <p>Do the same for the 4 M_AXIS signals, and verify that the Mode is master.</p> <p>No, do the same for ARESETN and ACLK, and select Signal&gt;reset_rtl and Signal&gt;clock_rtl respectively.</p> <p>In the Addressing and Memory tab, right-click on S00_AXI and select Remove Memory Map (this is a vestige of our original selection of a AXI memory-mapped slave as the IP).</p> <p>Now, go to Review and Package, and click Re-Package IP, and click OK.</p> <p>You can see that only 1 warning remains (irrelevant/old warnings can be removed by right-clicking messages and selecting Discard User Created Messages) - [IP_Flow 19-11770] Clock interface 'ACLK' has no FREQ_HZ parameter. This is ok.</p> <p>You can now close the temporary project and go back to the original project with the block design.</p> <p>Rerun the IP Status Report.</p> <p></p> <p>Refresh IP Catalog.</p> <p></p> <p>Click Upgrade Selected.</p> <p></p> <p>Generate Output Products will pop up. Select Generate.</p> <p>At this point, you will get some errors and critical warnings, but that is ok. Click Rerun for IP Status Report.</p> <p></p> <p>Now, if you discard old warnings and errors, you will see that there are no more critical warnings and errors. The block interfaces for our custom IP would have changed to\u00a0</p> <p></p> <p>AXI Stream is just a simplex (data flows only in one direction for a link), master-slave, synchronous, point-to-point link with no addressing. The AXI bus, on the other hand, is a bi-directional addressable (memory-mapped) interface with the main processor as the master. We need a bridge between AXI and AXIS to allow the main processor to send and receive data from the coprocessor. There are 2 options for us -\u00a0AXI Stream FIFO\u00a0and\u00a0AXI DMA. The former is simpler, and perhaps good enough for smaller data sets. However, for larger data, the latter is more efficient, though more complicated from a hardware as well as software perspective. It is a good idea to try AXI Stream FIFO first, before trying out AXI DMA (optional, but strongly recommended for performance and experience).</p> <p>AXI Stream FIFO\u00a0and\u00a0AXI DMA both perform MM2S and S2MM operations. MM2S stands for Memory-Mapped to Stream, where 'memory-mapped' refers to the connection using the AXI interface, where every peripheral is identified using a unique address range (memory-mapped input-output). S2MM, as you can guess easily, is Stream to Memory-Mapped.</p>"},{"location":"Lab_4/1_HLSIntro/","title":"High Level Synthesis, Measuring Performance","text":""},{"location":"Lab_4/1_HLSIntro/#introduction-to-high-level-synthesis","title":"Introduction to\u00a0High-level synthesis","text":"<p>High-level synthesis transforms C functions into hardware IPs.</p> <p>HLS works fairly well for inner blocks with fairly data-oriented (resource-dominated) functionality without complicated control flow structures. Examples would be digital signal processing, arithmetic on matrices, etc where loops have data-independent exit conditions.</p> <p>It is not very good for those outer blocks which typically involve complicated control structures (control dominated). HLS-based generation of a control-dominated circuit such as a microcontroller is a holy grail.\u00a0</p> <p>The HLS tool is temperamental - sometimes you get very good results, and sometimes you end up wondering what just happened. Sometimes even slight code changes that should have little/no functional relevance can produce substantially different hardware. Well, using an inherently sequential high-level language to produce inherently parallel hardware is challenging.</p> <p>Not all C code can be synthesized. Anything that depends on a\u00a0runtime environment\u00a0would not work. An example would be dynamic memory allocation\u00a0(no malloc). Keep in mind that the goal of HLS is not to create something which executes on a processor, it is to create a sort of a processor itself.</p> <p>Creating an HLS-based design based on default options might not yield a good IP/hardware. It will be kind of like going on an organized tour. You will get some feel of the place, you will have the bragging rights, but the experience is generally not so 'authentic'. You need to exert control of the hardware generated using various optimization directives as appropriate depending on the context, design requirements/ tradeoffs.</p> <p>The interface of the IP generated by the HLS can be</p> <ul> <li>AXIS. The IP generated is a drop-in replacement for the one you created in Lab 3, which is the option you should choose unless you wish to experiment. Note that the HLS-generated AXIS IP does not seem to work well with AXI DMA in the newer versions of Vitis.</li> <li>The default HLS Protocol. This can then be integrated into your AXIS co-processor in the 'COMPUTING' state through HDL.</li> <li>AXI4-Lite. This is pretty easy to use if you know what you are doing (adding registers and addressing etc).\u00a0</li> </ul>"},{"location":"Lab_4/1_HLSIntro/#hls-flow","title":"HLS Flow","text":"<p>A step-by-step tutorial to create a coprocessor that is functionally identical to that of the template coprocessor given in lab 1 (to add 4 numbers and return the sum, sum+1, sum+2, and sum+3) packaged in lab 3 is given here. Please try this out first.</p>"},{"location":"Lab_4/1_HLSIntro/#performance-analysis","title":"Performance analysis","text":"<p>The process of collecting information about a program dynamically (i.e., during runtime) is called\u00a0profiling.\u00a0 Many IDEs come with some sort of profiling tool.\u00a0 There are a lot of different approaches to profiling.</p> <p>A typical way of doing profiling is to sample the program counter through the debug interface, which is\u00a0supported by Xilinx tools\u00a0- the TCF profiler is very very easy to use\u00a0 - please try it out. Based on this, the profiler gives you statistics regarding what\u00a0fraction (percentage) of time\u00a0your program spends in each function. Profiling gives you clues regarding which function might be a good candidate for you to spend your time and money on - you wouldn't want to bother much about a function that is not a performance bottleneck. These improvements could be through algorithmic optimizations and/or hardware acceleration. \u00a0Note: You need to do 'Debug' rather than 'Run' at least once for the profile option to be active.\u00a0Note that you may need to loop the contents of each function several 1000s of times (after receiving the data just one time via the serial console) to get a statistically meaningful comparison between these two when profiling using the TCF profiler.</p> <p>Now, how do we measure the\u00a0exact time\u00a0taken to execute a specific segment of software code?</p> <p>If the application is running on top of an OS (e.g. FreeRTOS), the OS typically provides some sort of system call / software timers. You could use this to log the timestamps at various points in your software code which allows you to measure the execution times for various segments of your software code. You won't need specialized software tools or hardware (apart from the hardware timer which the OS needs) for this. However, the time resolution you get is typically not very high.</p> <p>We can also use a dedicated hardware timer to get the precise number of cycles required to execute a segment of software code.\u00a0The difference between the counter readings before and after the segment of software code you want to analyze will give you the number of cycles, and hence the time taken. Make sure that you do not have any unnecessary code between the two points where you read the counter. For example, printing the first reading of the counter immediately after reading it would be a bad idea.</p> <p>Using a hardware timer is the approach we follow in this lab. It is left entirely to you as a self-learning exercise.\u00a0 This will require you to integrate an\u00a0AXI Timer\u00a0in your hardware (Vivado) and use the appropriate driver functions in Vitis/SDK.\u00a0By now, you should have a hang of things and it should be easy enough as the timer/counter is a pretty simple peripheral.\u00a0A couple of hints:</p> <ul> <li>You need only one counter, whereas the timer IP block incorporates 2 counters by default. You can double-click the block in Vivado and uncheck the second one to reduce the hardware usage and synthesis time.</li> <li>You can get started with the xtmrctr_polled_example project for axis_timer_0 (tmrctr). You can get this from hardware_1_wrapper&gt;platform.spr&gt; Peripheral Drivers section of the Board Support Package. Try running this first, and later integrate the relevant parts\u00a0into your software C code.</li> </ul>"},{"location":"Lab_4/1_HLSIntro/#assignment-4","title":"Assignment 4","text":"<p>1) The assignment mainly involves creating the same coprocessor (that you created in Lab 1 and scaled up/packaged in Lab 3) using HLS and integrating it into the system. You can just use your lab 3 block design and use the HLS-generated co-processor as a drop-in replacement for the HDL-based co-processor of lab 3. The exact same\u00a0software C code should work, but the project has to be updated with the new .xsa file, as your hardware and hence bitstream is different. If you wish (not a requirement), you can\u00a0add\u00a0the HLS generated coprocessor into the system instead of\u00a0replacing\u00a0the lab 3 coprocessor.</p> <p>2) Further, you should integrate an AXI Timer into your block design, and modify your software C code to report the time taken by the</p> <ol> <li> <ol> <li>Software implementation of matrix multiplication. If you did not have the software version in Lab 3 and used pre-computed results, it is time to copy over the software version from Lab 2. If your code was such that the software version of multiplication was interspersed with the receiving of data from the serial console (RealTerm), please separate them out, i.e., receive the data first, and then do the matrix multiplication.</li> <li>HLS-generated hardware implementation of matrix multiplication.\u00a0</li> </ol> </li> <li> <p>Any overhead that is irrelevant to a comparison between hardware should be excluded from profiling/measurement of the time taken.</p> <ul> <li>The time taken for printing messages and receiving the data via serial (RealTerm) should not be included.</li> <li>Comment out messages such as 'Transmitting Data for test case', 'Receiving data for test case' etc. This can be done conveniently using the C preprocessor (#define - #ifdef - #endif), without having to manually comment/uncomment each line/block.</li> </ul> </li> <li>The time taken for the hardware version should be inclusive of the time taken for sending data to and receiving data from the coprocessor (i.e., writing to / reading from AXI Stream FIFO), as this is an unavoidable overhead* associated with offloading computations to hardware.<ul> <li>*This overhead can possibly be ignored when using DMA in a non-blocking fashion, i.e., the CPU is performing some other useful task while the DMA data transfer and co-processor computations are in progress.</li> </ul> </li> <li>It is suggested that you create two separate functions called from the main program - something like matrix_multiply_soft() and matrix_multiply_hard() for the software and the hardware versions respectively. This also facilitates profiling using the TCF profiler which can do profiling only at a function level. Note that you may need to call these two functions many times in a loop (after receiving the data just one time from the serial console) to get a statistically meaningful comparison between these two when you do profiling using the TCF profiler.</li> </ol> <p>3) You are also required to try\u00a0at least one possible optimization\u00a0in HLS and compare the performance on hardware (which wouldn't require any modifications to your software C code) with the vanilla (non-optimized) version. The C code for HLS needs to have appropriate pragmas inserted manually or graphically. This is a self-learning / self-exploration exercise.</p> <ul> <li>You should read and get an overview of the following 4 optimizations (a fair idea is good enough, detailed knowledge is not expected) from the document\u00a0https://www.xilinx.com/content/dam/xilinx/support/documentation/sw_manuals/xilinx2018_1/ug1270-vivado-hls-opt-methodology-guide.pdf. The page numbers below are the pages where the topic starts, not necessarily the only 4 pages you need to read. You can Google if you wish to know more about these.</li> </ul> <p>pragma HLS array_partition....83\\ pragma HLS dataflow...............91\\ pragma HLS pipeline................116\\ pragma HLS unroll....................125</p> <p>Note that while these optimizations are applied independently, some optimizations work well only when some other optimizations are also used. For example, doing pipelining or loop unrolling without partitioning the array wouldn't help much, as the bottleneck will be accessing the memory, 1 or 2 elements at a time. The effect of these optimizations is not always that deterministic though, given the nature and non-maturity of HLS tools.</p> <p>Also, note that some of these optimisations are done automatically by the HLS tools in the newer versions of Vitis. You'll be able to notice these in the reports, and can be controlled to some extent in the configuration file.</p>"},{"location":"Lab_4/1_HLSIntro/#submission-info","title":"Submission Info","text":"<p>Assignment 4\u00a0(7 marks)</p> <p>Demonstrate in week 9.</p> <p>Upload</p> <p>Upload a .zip file containing the</p> <ul> <li>the .cpp files used for HLS implementation and test/co-simulation. The directives.tcl file should also be included if the 'Directive Destination' is 'Directive File' instead of 'Source File'.</li> <li>.c/.h file(s) running on ARM Cortex A53 used to send data to the co-processor, including timer (only those you have modified).</li> <li>A screenshot of your IP integrator canvas, i.e., the block diagram (please do not upload the entire Vivado project folder).</li> <li>.xsa file(s).</li> <li>A text file containing the information printed on the serial console, which should have info on the time taken.</li> <li>Optional - a screenshot of the TCF profiler tab showing a comparison between the time spent for hardware and software versions of the matrix multiplication functions.</li> </ul> <p>used for the demo to the Canvas by 11:59 PM,\u00a021 Mar 2024.</p> <p>It should be as a .zip archive, with the filename \u00a0__4.zip. <p>Please\u00a0DO NOT\u00a0upload the whole project!</p> <p>References</p> <p>Here are some references that can help you get started with Vivado\u00a0High-Level\u00a0Synthesis\u00a0tool</p> <ul> <li>Xilinx official presentation slides introducing HLS</li> <li>A good Xilinx official presentation on optimization</li> <li>https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/Getting-Started-with-Vitis-HLS</li> <li>Vivado Design Hub - High-Level Synthesis. The documents here are very very useful.</li> <li>Vivado HLS flow on Zynq workshop: \u00a0just register for a Xilinx account then you can download all the material for the workshop. After finishing all the labs, you should be able to apply HLS to your project.</li> <li>Parallel Programming for FPGAs\u00a0: A very good free textbook on HLS (http://kastner.ucsd.edu/hlsbook/).</li> </ul>"},{"location":"Lab_4/2_HLSFLow/","title":"HLS Flow","text":""},{"location":"Lab_4/2_HLSFLow/#introduction","title":"Introduction","text":"<p>The following manual is for Vitis (Visual Studio Code based) unified IDE. The spirit of the instructions is quite similar for Vitis HLS (eclipse-based, which is being deprecated), if you wish to use that.</p> <p>You will need the template files\u00a0myip_v1_0_HLS.cpp\u00a0(CPP source for HLS) and\u00a0test_myip_v1_0_HLS.cpp\u00a0(Testbench).\u00a0As with the Lab 1 HDL template, the sample program receives 4 numbers, computes the sum, and sends back 4 numbers which are sum, sum+1, sum+2, and sum+3.\u00a0Read through these files and understand the implementation. You will notice that test_myip_v1_0_HLS.cpp is very similar to the other test programs that we have used. Have a good look at the similarities and differences.</p> <p>test_myip_v1_0_HLS.cpp is a testbench used for simulation only. It is not executed on the ARM Cortex A53 processor on the board. We will be doing 2 types of simulation.</p> <ul> <li>C simulation.<ul> <li>C simulation executes a pure software version of the files, where\u00a0myip_v1_0_HLS.cpp simply contains the function myip_v1_0_HLS() that is called by the main program in test_myip_v1_0_HLS.cpp. This is a very fast process, used to check the algorithmic correctness.</li> </ul> </li> <li> <p>RTL/C Cosimulation</p> <ul> <li>Here, instead of calling myip_v1_0_HLS() as a function, the corresponding RTL (=HDL) code generated through C Synthesis (=HLS) is simulated using the Vivado simulator (XSIM) behind the screens. This takes more time than C simulation (orders of magnitude more time for complex designs) and is used to test the functional correctness of the HDL generated by the HLS process. The test_myip_v1_0_HLS.cpp feeds data directly into the (simulated) S_AXIS of the coprocessor, and gets data directly from the (simulated) M_AXIS of the co-processor. AXI bus and AXI Stream FIFO are not involved.</li> </ul> </li> </ul> <p>test_fifo_myip_v1_0.c. is executed on the ARM Cortex A53 processor of the board, and exchanges data with the real coprocessor through the AXI Stream FIFO. As the coprocessor created using HLS is a drop-in replacement for the coprocessor packaged in lab 3, the same test_fifo_myip_v1_0.c can be used.</p>"},{"location":"Lab_4/2_HLSFLow/#creating-and-synthesizing-a-design","title":"Creating and Synthesizing a Design","text":"<p>Open Vitis.</p> <p>Select Open Workspace. Select a freshly created folder (create a folder using your operating system's file manager, e.g., explorer) for the HLS IP. If you are opening an existing design, you can also select it under Recent Workspaces.</p> <p></p> <p>Select\u00a0Create HLS Component. Specify a name (myip_v1_0_HLS) and path/location that doesn't involve underscores or spaces. Next.</p> <p>Accept the defaults for the Configuration File and click Next.</p> <p>In the Add Source Files dialog, add the design file (myip_v1_0_HLS.cpp), testbench (test_myip_v1_0_HLS.cpp), and the top function.\u00a0</p> <p></p> <p>It may take a few seconds after you click Browse in step 3 above before the top function myip_v1_0_HLS appears as an option. Select it and click ok.</p> <p></p> <p>Note that the above files will remain in their original location and won't get copied over to the project, there is no option to easily copy it over to the project. The files should be in a location that doesn't involve underscores or spaces.\u00a0Next.</p> <p>In the part number selection, search for xck26 and select xck26-sfvc784-2LV-c (which is the part number for the chip used on board). Next.</p> <p>Note: You may also be able to find it easily under Boards &gt; Kria KV260 Vision AI Starter Kit in Vitis HLS, but not in Vitis.</p> <p></p> <p>Enter 10ns or 100MHz, without a space between the quantity and the unit. Make sure that the rest of the settings are as below, which should be the case by default. Next.</p> <p></p> <p>Next. Finish.</p> <p>You will see myip_v1_0_HLS.cpp file under myip_v1_0_HLS&gt;Sources, and test_myip_v1_0_HLS.cpp under Test Bench in the workspace. Ensure that the contents are as expected. Later on, you need to modify these files as appropriate to implement assignment 4.</p> <p></p> <p>You can see all the settings under myip_v1_0_HLS&gt;Settings &gt; hls_config.cfg.</p> <p></p> <p>Under\u00a0 FLOW, Run C SIMULATION. This tests your program as standard software - an executable is created and run.</p> <p></p> <p>You can see that it completes successfully in the output console of VS Code (Vitis).</p> <p></p> <p>Now, run C SYNTHESIS. Once done, you can see the success message in the output console.</p> <p>You can now explore the various reports under C SYNTHESIS &gt; REPORTS.</p> <p></p> <p>Of particular interest are</p> <ul> <li>Synthesis &gt; Timing Estimate, Performance &amp; Resource Estimates.</li> <li>Schedule viewer (the result of the scheduling step in architectural synthesis, screenshot not shown here).</li> </ul> <p></p> <p>You can also see the HDL files generated by the HLS tools under myip_v1_0_HLS&gt;Output folder in the workspace.</p> <p></p> <p>Now, run C/RTL COSIMULATION. Once done, you can see the success message in the output console.</p> <p>This runs the HDL (RTL) code using the Vivado (XSIM) simulator, using the stimulus provided by the C testbench. You can see the success message in the output console.</p> <p>Finally, run PACKAGE. Once done, you can see the success message in the output console. The IP is now ready to be used in the Vivado project.</p> <p>Open Vivado. Create / Open a project (you can use a copy of the Lab 3 project). Add your Vitis workspace to the IP repository.</p> <p></p> <p>That is it. Now you will be able to see the IP in the IP catalog.\u00a0</p> <p></p> <p></p> <p>You can use the IP just like the AXIS IP you created in Lab 3. It is a drop-in replacement. You can delete the Lab 3 IP, and make the S_AXIS and M_AXIS connections to AXI Stream FIFO / AXI DMA. Clock and reset can be connected via connection automation.</p> <p>The rest of the process is standard - create HDL wrapper (if not set to auto-update) &gt; Generate Bitstream&gt; Export Hardware (including bitstream). The rest is in Vitis Classic. The exact same Vitis Classic project can be used (including all the source files), with the .xsa file refreshed to account for the new HLS IP instead of the HDL IP of Lab 3.</p>"},{"location":"Lab_4/2_HLSFLow/#optimizing-the-design","title":"Optimizing the Design","text":"<p>This section details how you can control the\u00a0hardware / architecture\u00a0generated using directives. These directives can be inserted as #pragma in your C-code, or graphically as shown below.</p> <p>Open the HLS Directive view on the right. Note that the directive view as shown below will appear only when the myip_v1_0_HLS.cpp is selected in the editor window. You can see that some directives that were in the template code, such as the HLS INTERFACE directive appear in the list of directives.</p> <p>Select the part of the code whose hardware architecture you wish to control, for example, the for loop myip_v1_0_HLS_for1 below. We already had a label myip_v1_0_HLS_for1 for the for loop in our source code for easy identification but is not mandatory*.</p> <p></p> <p>Select the directive. Here, we UNROLL the for loop selected above. You can also set the optional parameters, such as the unroll factor for UNROLL. You can choose whether the directive is to be inserted into the code as a #pragma, or to be inserted into the config file. We choose the former for now.</p> <p></p> <p>You can now see the directive in the source code.</p> <p></p> <p>*A label is necessary if we are inserting the directive into the config file. If you choose to insert the directive into the config file, you can see it as follows.</p> <p></p> <p>Run C Synthesis again. You can see that the timing, performance (latency) &amp; resource (FF, LUT, etc) estimates have changed.\u00a0</p> <p>Try separately with arbitrary precision and 32-bit precision by commenting/uncommenting the relevant lines in myip_v1_0_HLS.cpp. Do you notice a difference in timing, performance &amp; resource estimates once you run C synthesis?</p>"},{"location":"Lab_4/3_MultipleCoPro/","title":"Connecting Multiple Coprocessors (Optional)","text":"<p>This document describes how you can (optional) connect multiple coprocessors to your system.</p> <p>It is possible to connect 2 coprocessors through 2 AXI FIFOs (or AXI DMAs). This is not a requirement, but not a bad idea as you can compare the software, HLS, and HDL versions in one go. You just need to add one more AXI Stream FIFO IP from the IP catalog and make connections the same way you did for the first one. On the C side, the following should help. A similar idea can be used if you have 2 coprocessors connected through 2 AXI DMAs (or for any two instances of the same IP for that matter).</p> <p>XLlFifo FifoInstance0; \u00a0 \u00a0 // Device 0 instance XLlFifo InstancePtr0 = &amp;FifoInstance0; // Device 0 pointer XLlFifo FifoInstance1; \u00a0 \u00a0 // Device 1 instance XLlFifo InstancePtr1 = &amp;FifoInstance1; // Device 1 pointer \u00a0 int main() { \u00a0 \u00a0 int Status0 = XST_SUCCESS; \u00a0// can also use just a single status variable. \u00a0 \u00a0 int Status1 = XST_SUCCESS; \u00a0 \u00a0 \u00a0 XLlFifo_Config Config0; \u00a0 \u00a0// can also reuse the config pointer instead of having two. \u00a0 \u00a0 XLlFifo_Config Config1; \u00a0 \u00a0 \u00a0 / Initialize the Device Configuration Interface driver for FIFO0 / \u00a0 \u00a0 Config0 = XLlFfio_LookupConfig(XPAR_AXI_FIFO_0_DEVICE_ID); \u00a0 \u00a0 if (!Config0) { \u00a0 \u00a0 \u00a0 \u00a0 xil_printf(\"No config found for %d\\r\\n\", XPAR_AXI_FIFO_0_DEVICE_ID); \u00a0 \u00a0 \u00a0 \u00a0 return XST_FAILURE; \u00a0 \u00a0 } \u00a0 \u00a0 \u00a0 Status0 = XLlFifo_CfgInitialize(InstancePtr0, Config0, Config0-&gt;BaseAddress); \u00a0 \u00a0 if (Status0 != XST_SUCCESS) { \u00a0 \u00a0 \u00a0 \u00a0 xil_printf(\"Initialization failed\\r\\n\"); \u00a0 \u00a0 \u00a0 \u00a0 return XST_FAILURE; \u00a0 \u00a0 } \u00a0 \u00a0 \u00a0 \u00a0/ Initialize the Device Configuration Interface driver for FIFO1 / \u00a0 \u00a0 Config1 = XLlFfio_LookupConfig(XPAR_AXI_FIFO_1_DEVICE_ID); \u00a0 \u00a0 if (!Config1) { \u00a0 \u00a0 \u00a0 \u00a0 xil_printf(\"No config found for %d\\r\\n\", XPAR_AXI_FIFO_1_DEVICE_ID); \u00a0 \u00a0 \u00a0 \u00a0 return XST_FAILURE; \u00a0 \u00a0 } \u00a0 \u00a0 \u00a0 Status1 = XLlFifo_CfgInitialize(InstancePtr1, Config1, Config1-&gt;BaseAddress); \u00a0 \u00a0 if (Status1 != XST_SUCCESS) { \u00a0 \u00a0 \u00a0 \u00a0 xil_printf(\"Initialization failed\\r\\n\"); \u00a0 \u00a0 \u00a0 \u00a0 return XST_FAILURE; \u00a0 \u00a0 } \u00a0 \u00a0 \u00a0 Status0 = XLlFifo_Status(InstancePtr0); // use the correct driver pointer depending on the device instance you are interacting with. \u00a0 \u00a0 Status1 = XLlFifo_Status(InstancePtr1);</p>"},{"location":"Project/1_ProjDesc/","title":"Project Description","text":""},{"location":"Project/1_ProjDesc/#introduction","title":"Introduction","text":""},{"location":"Project/1_ProjDesc/#introduction_1","title":"Introduction","text":"<p>The goal of this project is to create a hardware accelerator for a\u00a0multilayer perceptron\u00a0neural network.\u00a0A\u00a0multilayer perceptron\u00a0(MLP) is a class of\u00a0feedforward artificial neural networks. An MLP consists of, at least, three layers of nodes: an input layer, a hidden layer, and an output layer. Except for the input nodes, each node is a neuron that usually uses a nonlinear\u00a0activation function. Backpropagation is a popular\u00a0supervised learning technique for training MLPs . MLP can also be trained using other techniques such as Genetic Algorithms, Particle Swarm Optimization, etc.</p> <p>We will be implementing the hardware accelerator for inference (prediction), not for training. Training the neural network (which involves optimizing the weights of the connections in the network to minimize prediction error) can be done separately on a PC / Laptop and the weights can be stored in a file.\u00a0For the sample data given on this page, the training is already done and the weights are provided. Implementing the architecture mentioned below and using these weights is good enough to meet the basic requirements. Even if you are using a different neural network architecture or dataset, the training can still be done offline.</p> <p>We will need to implement prediction (predicting the label of a new input data) in 3 different ways</p> <ol> <li>SOFT: A pure software implementation on the ARM Cortex A53.</li> <li>HARD_HDL: An AXIS co-processor implementing the neural network in hardware, written in HDL. This should be able to receive the weights and the data from the software running on ARM Cortex A53, and return the predicted labels.</li> <li>HARD_HLS: An AXI / AXI Lite / AXIS co-processor implementing the neural network in hardware, which is at least partly created using the HLS tool. This should be able to receive the weights and the data from the software running on ARM Cortex A53, and return the predicted labels.\u00a0</li> </ol>"},{"location":"Project/1_ProjDesc/#procedure","title":"Procedure","text":"<p>You will send the data from the PC via the serial console (RealTerm, through the option to send a file).\u00a0It is fine to hardcode the size of the data in your program; however, the data itself should be sent via the serial console.</p> <p>The C program running on the ARM Cortex A53 processor should receive the dataset, get the prediction done through SOFT or HARD_HDL or HARD_HLS, and send the predictions back to the console. This can be captured in a file, which can then be compared against the actual labels to compute the prediction accuracy (using, say, Excel).</p> <p>The weights can be hard-coded in the C program or sent from the PC, but it should not be hard-coded in your coprocessor design, i.e., the coprocessor should be able to deal with different weights. This allows the same coprocessor (hardware) to deal with possibly different datasets and weights, provided the neural network architecture and data dimensionality do not change. At least, the data dimensionality should not exceed what you had designed for, i.e., 7 for the design mentioned below on this page. A lower-dimensional data can be easily dealt with by setting the weights corresponding to unused features to 0. A dataset that has more samples / data points can be dealt with by having an appropriate C program that can break it into chunks which the coprocessor can accept, which is 64 in our case.</p> <p>You can have 3 separate C programs and 2 different hardware for demonstrating the functionality of the 3 predictors. However, it will be more elegant (though not mandatory) to use a single hardware platform, and a C program written such that the selection between SOFT, HARD_HDL, or HARD_HLS to do the prediction can be done easily. For example, this can be by sending some sort of message from the serial console.\u00a0</p> <p>It is required to have a timer to compare the time taken by the three predictors.</p> <p>You can make your own choices regarding the neural network architecture such as the number of hidden layers, the number of neurons in each hidden layer, etc, subject to some minimum requirements:</p> <ul> <li>There should be at least one hidden layer.</li> <li>There should be at least 2 neurons in the hidden layer(s) using a non-linear activation function that is not piecewise linear (e.g., not ReLU or variants).</li> <li>There are no restrictions regarding the activation functions used elsewhere, i.e., the third neuron onwards in the hidden layer, or additional hidden layers.\u00a0</li> </ul> <p>The sample data section below has data and pre-trained weights for the neural network architecture described in that section, which is enough to meet the basic requirements. You are free to explore other architecture and / or other data. The focus though, is on exploring hardware architectures rather than exploring different neural network architectures - the module is on hardware design and machine learning just happens to be the application we chose to accelerate (which we thought would give many who are new to machine learning some flavor of it).</p> <p>Having said that, exploring some hardware related aspects (such as dealing with overflows, negatives, precision issues, etc) wouldn't be possible with the pre-trained network above - you will have to do your own training for that.</p> <p>It is not just about getting things functionally/algorithmically correct. It is about having a systematic design and being able to appreciate the various tradeoffs. There is no fixed requirement regarding accuracy, resource usage, or performance -\u00a0all these are interdependent. Your design should be Pareto-optimal, i.e., it\u00a0should be\u00a0such\u00a0that one figure of merit cannot be improved without compromising on another.</p>"},{"location":"Project/1_ProjDesc/#sample-data","title":"Sample data","text":"<p>You can any dataset you like. A synthetic dataset (a distorted version of the original wine dataset) as well as the weights for the neural network are given below.</p> <p>The input layer has 7 nodes, corresponding to 7 features. The matrix contained in\u00a0X.csv\u00a0is a\u00a064 x 7 matrix, corresponding to 64 data points, each with 7 features.</p> <p>There is 1 hidden layer having 2 neurons, with the neurons having 1 (decimal) as bias input (you can consider this as 255 or 256\u00a0as you wish in the 0.8 unsigned fixed-point format we use).\u00a0In other words, we do\u00a0 where\u00a0is the bias and \u00a0is considered 255 or 256. Why is 256 ok when it doesn't fit into 8 bits? Because 256 (representing 1.0), can be implicitly used by doing &lt;&lt; 8 (which can be done by appropriate bit wiring) instead of multiplication. Alternatively, you can simply do . Please keep in mind the representation format, and things will be clearer.</p> <p>The neurons in the hidden layer have a sigmoid activation function as given below.\u00a0 The exact formula used is , where is an integer in the interval\u00a0 [0, 255], i.e., in the 0.8 format. This uses\u00a0only the middle part of the curve, so the amount of non-linearity isn't very high.</p> <p></p> <p>The sigmoid function can be computed using a lookup table given in\u00a0sigmoid.csv. The input to the function is used as an index to look up the output of the function. It is also fine to compute it directly using the formula if you wish. Which would be better for 8-bit scenario? Using a table or computing it directly? How about for 32-bit numbers?</p> <p>The file\u00a0w_hid.csv\u00a0contains the weights for the hidden layer. This is an 8 x 2 matrix, with the first row containing the weight for the bias term, and the rest of the 7 rows containing weights for each of the features. The two columns represent the weights corresponding to the two neurons in the hidden layer.</p> <p>The output layer\u00a0has a bias input too, and a linear activation function i.e., the output is simply the weighted sum of inputs to the neurons (and bias). The 3 x 1 weight matrix given in\u00a0w_out.csv, where the first element is the weight of the bias term, and the rest of the two are weights for the outputs from the hidden later.</p> <p>The labels for verification can be found in labels. labels.csv.</p> <p>Note: In unsigned 0.8 fixed-point format, there is an implicit scale factor of 256. So whenever you have a multiplication of two 0.8 format numbers, you need to scale down by 256. Whenever you have a division, you should scale up by 256. Addition and subtraction don't change the scale. When you are doing multiply and accumulate, you can do the scaling down by 256 after accumulation, which will preserve precision better than scaling down after every single multiplication.</p>"},{"location":"Project/1_ProjDesc/#links","title":"Links","text":"<p>https://playground.tensorflow.org\u00a0- very nice interactive visualization of neural networks.</p> <p>https://web.archive.org/web/20150317210621/https://www4.rgu.ac.uk/files/chapter3%20-%20bp.pdf\u00a0(see page 20 for a numerical example)</p>"},{"location":"Project/1_ProjDesc/#tips-food-for-thought","title":"Tips / Food For Thought","text":"<p>The above sample data was curated such that you won't have an intermediate result that cannot be represented in 0.8 unsigned fixed-point format at any stage in computation. In a real-world dataset, this can't be guaranteed. Some possible approaches to mitigate this issue are</p> <ol> <li>Scaling down the input even further - this would mean even more quantization errors / limitations on the input range.</li> <li>Using more bits for intermediate results.</li> <li>Having some sort of saturation logic (instead of 249+7 = 0, it is better to do 249+7=255).</li> <li>Having a signed representation system instead of unsigned - this will allow negatives, though it will reduce the range on the positive side.</li> </ol> <p>When you convert one intermediate representation / result to another, you might want to consider other rounding modes too. Right now, you just\u00a0truncate, by simply dropping the least significant bits.\u00a0 This happens when you divide by 256 - you are essentially converting a 16-bit representation with a scale of 256*256 to an 8-bit representation with a scale of 256 - you do so by dropping 8 LSBs. What if the 16-bit value is, say, 1000 0001 1111 1110? Wouldn't it be more accurate if it is converted to\u00a01000 0010 instead of\u00a01000 0001?</p> <p>Another possible way to represent numbers is using floating-point representation. Unlike a fixed-point system where the position of the point is fixed and implicit (and adjusted whenever an operation such as multiplication or division changes it), in floating-point, the position of the point is encoded separately using dedicated bits for the purpose. You can read more about it here.</p> <p>You can google for terms such as pruning, quantization, encoding, approximate computing, etc. in the context of neural networks if you are interested.</p> <p>The exact way you do the computations and the precision to use is entirely up to you.\u00a0</p> <ul> <li>It is a good idea to mimic the representation system you are planning to implement in hardware in your C implementation first. Later on, try it out in HLS as well, where you can mimic the hardware more closely through ap_uint&lt;&gt; datatype, which allows for arbitrary precision (not just 32-bit as vanilla C).</li> <li>This way, there will be a closer correspondence between C and HDL implementations - which means you will have a better idea of what exactly you are implementing, and the results you should get in each step, and hence you will have an easier time debugging.</li> <li>Also, if you are doing your own training, you can fine-tune the number of hidden layer neurons, etc. using your C implementation before setting the corresponding parameters in HDL.</li> <li>A single hidden layer should be sufficient for many practical applications and having multiple hidden layers could be problematic in certain situations.</li> </ul>"},{"location":"Project/2_EvalCrit/","title":"Project Evaluation Criteria, Deliverables","text":""},{"location":"Project/2_EvalCrit/#evaluation-criteria","title":"Evaluation Criteria","text":"<p>The marks below are out of 100, which will be scaled down to 20 marks for eventual grading.</p> <ul> <li>C-implementation (SOFT):\u00a015\u00a0marks<ul> <li>10 marks for running on PC (only if it doesn't run on FPGA board).</li> <li>15 marks for being able to run on the FPGA board, with a convincing demo.</li> </ul> </li> <li>HDL implementation (HARD_HDL):\u00a040\u00a0marks<ul> <li>10 marks for being able to simulate the hardware convincingly.</li> <li>10 marks for being able to synthesize without any undesirable warnings (warnings are ok as long as you are able to explain the reasons for the warnings, and convince us that it is acceptable).</li> <li>10 marks for full functionality on the board.</li> <li>10 marks for optimization efforts.</li> </ul> </li> <li>HLS implementation (HARD_HLS):\u00a025\u00a0marks<ul> <li>5 marks for being able to do RTL/C cosimulation.</li> <li>10 marks for being able to run it on the board.</li> <li>10 marks for appropriate optimization efforts.</li> </ul> </li> <li>Presentation:10\u00a0marks</li> <li>Discretionary component:10\u00a0marks<ul> <li>Innovations in design or demo, overall impression.</li> </ul> </li> </ul>"},{"location":"Project/2_EvalCrit/#list-of-deliverables","title":"List of deliverables","text":"<ul> <li>Presentation: Please make a presentation of\u00a0about 3-5 slides\u00a0(do not exceed 5)\u00a0describing the key features/results of your design.<ul> <li>Explain the hardware architecture(s), highlighting what you did differently.\u00a0</li> <li>Compare speed-ups (time taken for Software vs HDL vs HLS versions)</li> <li>Compare hardware utilisations (number of LUTs, FFs, DSPs, etc.) of various implementations.\u00a0</li> <li>Do not waste slides\u00a0reiterating the problem statement / the original / standard algorithms / obvious stuff.</li> </ul> </li> <li>Demonstration: The presentation should also include a demonstration to show that your design is working.\u00a0<ul> <li>Showing the speed-ups of various implementations.\u00a0</li> <li>The demonstration and presentation should take no more than 10 minutes. </li> <li>Keep the demo (necessary bitstreams, compiled programs, etc) ready by your time slot. Any delay will result in a penalty.</li> </ul> </li> <li>Upload design: A zip file containing your design(s) should be made and the presentation should be included in it.\u00a0<ul> <li>The presentation (ppt/pdf)</li> <li>Include all the source (design files and testbenches - .v/.vhd/.h/.c/.cpp) and data files (.txt/.csv) you have created / modified.</li> <li>.xsa file(s).</li> <li>If the files are different for different designs, give a proper suffix to file names - e.g. design_1_wrapper_HARD_HDL.xsa, test_fifo_myip_v1_0_HARD_HLS.c.</li> <li>DO NOT upload the whole project folder(s).</li> <li>Use the following naming convention for the zip file.\u00a001__Project.zip.\u00a0 <li>The deadline for uploading the zip file is 12 April.</li>"},{"location":"Project/3_EvalSched/","title":"Evaluation Schedule","text":""},{"location":"Project/3_EvalSched/#to-be-populated","title":"To be Populated","text":""}]}